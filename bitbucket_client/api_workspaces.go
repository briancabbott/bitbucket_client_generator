/*
 * Bitbucket API
 *
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * API version: 2.0
 * Contact: support@bitbucket.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bitbucket_client

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type WorkspacesApi interface {

	/*
	 * UserPermissionsWorkspacesGet Method for UserPermissionsWorkspacesGet
	 * Returns an object for each workspace the caller is a member of, and
their effective role - the highest level of privilege the caller has.
If a user is a member of multiple groups with distinct roles, only the
highest level is returned.

Permissions can be:

* `owner`
* `collaborator`
* `member`

Example:

```
$ curl https://api.bitbucket.org/2.0/user/permissions/workspaces

{
  "pagelen": 10,
  "page": 1,
  "size": 1,
  "values": [
    {
      "type": "workspace_membership",
      "permission": "owner",
      "last_accessed": "2019-03-07T12:35:02.900024+00:00",
      "added_on": "2018-10-11T17:42:02.961424+00:00",
      "user": {
        "type": "user",
        "uuid": "{470c176d-3574-44ea-bb41-89e8638bcca4}",
        "nickname": "evzijst",
        "display_name": "Erik van Zijst",
      },
      "workspace": {
        "type": "workspace",
        "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
        "slug": "bbworkspace1",
        "name": "Atlassian Bitbucket",
      }
    }
  ]
}
```

Results may be further [filtered or sorted](../../../meta/filtering) by
workspace or permission by adding the following query string parameters:

* `q=workspace.slug="bbworkspace1"` or `q=permission="owner"`
* `sort=workspace.slug`

Note that the query parameter values need to be URL escaped so that `=`
would become `%3D`.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return WorkspacesApiApiUserPermissionsWorkspacesGetRequest
	 */
	UserPermissionsWorkspacesGet(ctx _context.Context) WorkspacesApiApiUserPermissionsWorkspacesGetRequest

	/*
	 * UserPermissionsWorkspacesGetExecute executes the request
	 * @return PaginatedWorkspaceMemberships
	 */
	UserPermissionsWorkspacesGetExecute(r WorkspacesApiApiUserPermissionsWorkspacesGetRequest) (PaginatedWorkspaceMemberships, *_nethttp.Response, error)

	/*
	 * WorkspacesGet Method for WorkspacesGet
	 * Returns a list of workspaces accessible by the authenticated user.

Example:

```
$ curl https://api.bitbucket.org/2.0/workspaces

{
  "pagelen": 10,
  "page": 1,
  "size": 1,
  "values": [
    {
        "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
        "links": {
            "owners": {
                "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1/members?q=permission%3D%22owner%22"
            },
            "self": {
                "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1"
            },
            "repositories": {
                "href": "https://api.bitbucket.org/2.0/repositories/bbworkspace1"
            },
            "snippets": {
                "href": "https://api.bitbucket.org/2.0/snippets/bbworkspace1"
            },
            "html": {
                "href": "https://bitbucket.org/bbworkspace1/"
            },
            "avatar": {
                "href": "https://bitbucket.org/workspaces/bbworkspace1/avatar/?ts=1543465801"
            },
            "members": {
                "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1/members"
            },
            "projects": {
                "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1/projects"
            }
        },
        "created_on": "2018-11-14T19:15:05.058566+00:00",
        "type": "workspace",
        "slug": "bbworkspace1",
        "is_private": true,
        "name": "Atlassian Bitbucket"
    }
  ]
}
```

Results may be further [filtered or sorted](../meta/filtering) by
workspace or permission by adding the following query string parameters:

* `q=slug="bbworkspace1"` or `q=is_private=true`
* `sort=created_on`

Note that the query parameter values need to be URL escaped so that `=`
would become `%3D`.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return WorkspacesApiApiWorkspacesGetRequest
	 */
	WorkspacesGet(ctx _context.Context) WorkspacesApiApiWorkspacesGetRequest

	/*
	 * WorkspacesGetExecute executes the request
	 * @return PaginatedWorkspaces
	 */
	WorkspacesGetExecute(r WorkspacesApiApiWorkspacesGetRequest) (PaginatedWorkspaces, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspaceGet Method for WorkspacesWorkspaceGet
	 * Returns the requested workspace.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspaceGetRequest
	 */
	WorkspacesWorkspaceGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspaceGetRequest

	/*
	 * WorkspacesWorkspaceGetExecute executes the request
	 * @return Workspace
	 */
	WorkspacesWorkspaceGetExecute(r WorkspacesApiApiWorkspacesWorkspaceGetRequest) (Workspace, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspaceHooksGet Method for WorkspacesWorkspaceHooksGet
	 * Returns a paginated list of webhooks installed on this workspace.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspaceHooksGetRequest
	 */
	WorkspacesWorkspaceHooksGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspaceHooksGetRequest

	/*
	 * WorkspacesWorkspaceHooksGetExecute executes the request
	 * @return PaginatedWebhookSubscriptions
	 */
	WorkspacesWorkspaceHooksGetExecute(r WorkspacesApiApiWorkspacesWorkspaceHooksGetRequest) (PaginatedWebhookSubscriptions, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspaceHooksPost Method for WorkspacesWorkspaceHooksPost
	 * Creates a new webhook on the specified workspace.

Workspace webhooks are fired for events from all repositories contained
by that workspace.

Note that only owners can install webhooks on workspaces.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspaceHooksPostRequest
	 */
	WorkspacesWorkspaceHooksPost(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspaceHooksPostRequest

	/*
	 * WorkspacesWorkspaceHooksPostExecute executes the request
	 * @return WebhookSubscription
	 */
	WorkspacesWorkspaceHooksPostExecute(r WorkspacesApiApiWorkspacesWorkspaceHooksPostRequest) (WebhookSubscription, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspaceHooksUidDelete Method for WorkspacesWorkspaceHooksUidDelete
	 * Deletes the specified webhook subscription from the given workspace.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param uid Installed webhook's ID
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspaceHooksUidDeleteRequest
	 */
	WorkspacesWorkspaceHooksUidDelete(ctx _context.Context, uid string, workspace string) WorkspacesApiApiWorkspacesWorkspaceHooksUidDeleteRequest

	/*
	 * WorkspacesWorkspaceHooksUidDeleteExecute executes the request
	 */
	WorkspacesWorkspaceHooksUidDeleteExecute(r WorkspacesApiApiWorkspacesWorkspaceHooksUidDeleteRequest) (*_nethttp.Response, error)

	/*
	 * WorkspacesWorkspaceHooksUidGet Method for WorkspacesWorkspaceHooksUidGet
	 * Returns the webhook with the specified id installed on the given
workspace.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param uid Installed webhook's ID
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspaceHooksUidGetRequest
	 */
	WorkspacesWorkspaceHooksUidGet(ctx _context.Context, uid string, workspace string) WorkspacesApiApiWorkspacesWorkspaceHooksUidGetRequest

	/*
	 * WorkspacesWorkspaceHooksUidGetExecute executes the request
	 * @return WebhookSubscription
	 */
	WorkspacesWorkspaceHooksUidGetExecute(r WorkspacesApiApiWorkspacesWorkspaceHooksUidGetRequest) (WebhookSubscription, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspaceHooksUidPut Method for WorkspacesWorkspaceHooksUidPut
	 * Updates the specified webhook subscription.

The following properties can be mutated:

* `description`
* `url`
* `active`
* `events`
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param uid Installed webhook's ID
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspaceHooksUidPutRequest
	 */
	WorkspacesWorkspaceHooksUidPut(ctx _context.Context, uid string, workspace string) WorkspacesApiApiWorkspacesWorkspaceHooksUidPutRequest

	/*
	 * WorkspacesWorkspaceHooksUidPutExecute executes the request
	 * @return WebhookSubscription
	 */
	WorkspacesWorkspaceHooksUidPutExecute(r WorkspacesApiApiWorkspacesWorkspaceHooksUidPutRequest) (WebhookSubscription, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspaceMembersGet Method for WorkspacesWorkspaceMembersGet
	 * Returns all members of the requested workspace.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspaceMembersGetRequest
	 */
	WorkspacesWorkspaceMembersGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspaceMembersGetRequest

	/*
	 * WorkspacesWorkspaceMembersGetExecute executes the request
	 * @return PaginatedWorkspaceMemberships
	 */
	WorkspacesWorkspaceMembersGetExecute(r WorkspacesApiApiWorkspacesWorkspaceMembersGetRequest) (PaginatedWorkspaceMemberships, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspaceMembersMemberGet Method for WorkspacesWorkspaceMembersMemberGet
	 * Returns the workspace membership, which includes
a `User` object for the member and a `Workspace` object
for the requested workspace.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param member Member's UUID or Atlassian ID.
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspaceMembersMemberGetRequest
	 */
	WorkspacesWorkspaceMembersMemberGet(ctx _context.Context, member string, workspace string) WorkspacesApiApiWorkspacesWorkspaceMembersMemberGetRequest

	/*
	 * WorkspacesWorkspaceMembersMemberGetExecute executes the request
	 * @return WorkspaceMembership
	 */
	WorkspacesWorkspaceMembersMemberGetExecute(r WorkspacesApiApiWorkspacesWorkspaceMembersMemberGetRequest) (WorkspaceMembership, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspacePermissionsGet Method for WorkspacesWorkspacePermissionsGet
	 * Returns the list of members in a workspace
and their permission levels.
Permission can be:
* `owner`
* `collaborator`
* `member`

Example:

```
$ curl -X https://api.bitbucket.org/2.0/workspaces/bbworkspace1/permissions

{
    "pagelen": 10,
    "values": [
        {
            "permission": "owner",
            "type": "workspace_membership",
            "user": {
                "type": "user",
                "uuid": "{470c176d-3574-44ea-bb41-89e8638bcca4}",
                "display_name": "Erik van Zijst",
            },
            "workspace": {
                "type": "workspace",
                "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
                "slug": "bbworkspace1",
                "name": "Atlassian Bitbucket",
            }
        },
        {
            "permission": "member",
            "type": "workspace_membership",
            "user": {
                "type": "user",
                "nickname": "seanaty",
                "display_name": "Sean Conaty",
                "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
            },
            "workspace": {
                "type": "workspace",
                "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
                "slug": "bbworkspace1",
                "name": "Atlassian Bitbucket",
            }
        }
    ],
    "page": 1,
    "size": 2
}
```

Results may be further [filtered](../../../meta/filtering) by
permission by adding the following query string parameters:

* `q=permission="owner"`
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspacePermissionsGetRequest
	 */
	WorkspacesWorkspacePermissionsGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspacePermissionsGetRequest

	/*
	 * WorkspacesWorkspacePermissionsGetExecute executes the request
	 * @return PaginatedWorkspaceMemberships
	 */
	WorkspacesWorkspacePermissionsGetExecute(r WorkspacesApiApiWorkspacesWorkspacePermissionsGetRequest) (PaginatedWorkspaceMemberships, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspacePermissionsRepositoriesGet Method for WorkspacesWorkspacePermissionsRepositoriesGet
	 * Returns an object for each repository permission for all of a
workspace's repositories.

Permissions returned are effective permissions: the highest level of
permission the user has. This does not distinguish between direct and
indirect (group) privileges.

Only users with admin permission for the team may access this resource.

Permissions can be:

* `admin`
* `write`
* `read`

Example:

```
$ curl https://api.bitbucket.org/2.0/workspaces/atlassian_tutorial/permissions/repositories

{
  "pagelen": 10,
  "values": [
    {
      "type": "repository_permission",
      "user": {
        "type": "user",
        "display_name": "Erik van Zijst",
        "uuid": "{d301aafa-d676-4ee0-88be-962be7417567}"
      },
      "repository": {
        "type": "repository",
        "name": "geordi",
        "full_name": "atlassian_tutorial/geordi",
        "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
      },
      "permission": "admin"
    },
    {
      "type": "repository_permission",
      "user": {
        "type": "user",
        "display_name": "Sean Conaty",
        "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
      },
      "repository": {
        "type": "repository",
        "name": "geordi",
        "full_name": "atlassian_tutorial/geordi",
        "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
      },
      "permission": "write"
    },
    {
      "type": "repository_permission",
      "user": {
        "type": "user",
        "display_name": "Jeff Zeng",
        "uuid": "{47f92a9a-c3a3-4d0b-bc4e-782a969c5c72}"
      },
      "repository": {
        "type": "repository",
        "name": "whee",
        "full_name": "atlassian_tutorial/whee",
        "uuid": "{30ba25e9-51ff-4555-8dd0-fc7ee2fa0895}"
      },
      "permission": "admin"
    }
  ],
  "page": 1,
  "size": 3
}
```

Results may be further [filtered or sorted](../../../../meta/filtering)
by repository, user, or permission by adding the following query string
parameters:

* `q=repository.name="geordi"` or `q=permission>"read"`
* `sort=user.display_name`

Note that the query parameter values need to be URL escaped so that `=`
would become `%3D`.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest
	 */
	WorkspacesWorkspacePermissionsRepositoriesGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest

	/*
	 * WorkspacesWorkspacePermissionsRepositoriesGetExecute executes the request
	 * @return PaginatedRepositoryPermissions
	 */
	WorkspacesWorkspacePermissionsRepositoriesGetExecute(r WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest) (PaginatedRepositoryPermissions, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspacePermissionsRepositoriesRepoSlugGet Method for WorkspacesWorkspacePermissionsRepositoriesRepoSlugGet
	 * Returns an object for the repository permission of each user in the
requested repository.

Permissions returned are effective permissions: the highest level of
permission the user has. This does not distinguish between direct and
indirect (group) privileges.

Only users with admin permission for the repository may access this resource.

Permissions can be:

* `admin`
* `write`
* `read`

Example:

```
$ curl https://api.bitbucket.org/2.0/workspaces/atlassian_tutorial/permissions/repositories/geordi

{
  "pagelen": 10,
  "values": [
    {
      "type": "repository_permission",
      "user": {
        "type": "user",
        "display_name": "Erik van Zijst",
        "uuid": "{d301aafa-d676-4ee0-88be-962be7417567}"
      },
      "repository": {
        "type": "repository",
        "name": "geordi",
        "full_name": "atlassian_tutorial/geordi",
        "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
      },
      "permission": "admin"
    },
    {
      "type": "repository_permission",
      "user": {
        "type": "user",
        "display_name": "Sean Conaty",
        "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
      },
      "repository": {
        "type": "repository",
        "name": "geordi",
        "full_name": "atlassian_tutorial/geordi",
        "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
      },
      "permission": "write"
    }
  ],
  "page": 1,
  "size": 2
}
```

Results may be further [filtered or sorted](../../../../meta/filtering)
by user, or permission by adding the following query string parameters:

* `q=permission>"read"`
* `sort=user.display_name`

Note that the query parameter values need to be URL escaped so that `=`
would become `%3D`.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest
	 */
	WorkspacesWorkspacePermissionsRepositoriesRepoSlugGet(ctx _context.Context, repoSlug string, workspace string) WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest

	/*
	 * WorkspacesWorkspacePermissionsRepositoriesRepoSlugGetExecute executes the request
	 * @return PaginatedRepositoryPermissions
	 */
	WorkspacesWorkspacePermissionsRepositoriesRepoSlugGetExecute(r WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest) (PaginatedRepositoryPermissions, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspaceProjectsGet Method for WorkspacesWorkspaceProjectsGet
	 * Returns the list of projects in this workspace.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspaceProjectsGetRequest
	 */
	WorkspacesWorkspaceProjectsGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspaceProjectsGetRequest

	/*
	 * WorkspacesWorkspaceProjectsGetExecute executes the request
	 * @return PaginatedProjects
	 */
	WorkspacesWorkspaceProjectsGetExecute(r WorkspacesApiApiWorkspacesWorkspaceProjectsGetRequest) (PaginatedProjects, *_nethttp.Response, error)

	/*
	 * WorkspacesWorkspaceProjectsProjectKeyGet Method for WorkspacesWorkspaceProjectsProjectKeyGet
	 * Returns the requested project.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param projectKey The project in question. This is the actual `key` assigned to the project. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return WorkspacesApiApiWorkspacesWorkspaceProjectsProjectKeyGetRequest
	 */
	WorkspacesWorkspaceProjectsProjectKeyGet(ctx _context.Context, projectKey string, workspace string) WorkspacesApiApiWorkspacesWorkspaceProjectsProjectKeyGetRequest

	/*
	 * WorkspacesWorkspaceProjectsProjectKeyGetExecute executes the request
	 * @return Project
	 */
	WorkspacesWorkspaceProjectsProjectKeyGetExecute(r WorkspacesApiApiWorkspacesWorkspaceProjectsProjectKeyGetRequest) (Project, *_nethttp.Response, error)
}

// WorkspacesApiService WorkspacesApi service
type WorkspacesApiService service

type WorkspacesApiApiUserPermissionsWorkspacesGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	q *string
	sort *string
}

func (r WorkspacesApiApiUserPermissionsWorkspacesGetRequest) Q(q string) WorkspacesApiApiUserPermissionsWorkspacesGetRequest {
	r.q = &q
	return r
}
func (r WorkspacesApiApiUserPermissionsWorkspacesGetRequest) Sort(sort string) WorkspacesApiApiUserPermissionsWorkspacesGetRequest {
	r.sort = &sort
	return r
}

func (r WorkspacesApiApiUserPermissionsWorkspacesGetRequest) Execute() (PaginatedWorkspaceMemberships, *_nethttp.Response, error) {
	return r.ApiService.UserPermissionsWorkspacesGetExecute(r)
}

/*
 * UserPermissionsWorkspacesGet Method for UserPermissionsWorkspacesGet
 * Returns an object for each workspace the caller is a member of, and
their effective role - the highest level of privilege the caller has.
If a user is a member of multiple groups with distinct roles, only the
highest level is returned.

Permissions can be:

* `owner`
* `collaborator`
* `member`

Example:

```
$ curl https://api.bitbucket.org/2.0/user/permissions/workspaces

{
  "pagelen": 10,
  "page": 1,
  "size": 1,
  "values": [
    {
      "type": "workspace_membership",
      "permission": "owner",
      "last_accessed": "2019-03-07T12:35:02.900024+00:00",
      "added_on": "2018-10-11T17:42:02.961424+00:00",
      "user": {
        "type": "user",
        "uuid": "{470c176d-3574-44ea-bb41-89e8638bcca4}",
        "nickname": "evzijst",
        "display_name": "Erik van Zijst",
      },
      "workspace": {
        "type": "workspace",
        "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
        "slug": "bbworkspace1",
        "name": "Atlassian Bitbucket",
      }
    }
  ]
}
```

Results may be further [filtered or sorted](../../../meta/filtering) by
workspace or permission by adding the following query string parameters:

* `q=workspace.slug="bbworkspace1"` or `q=permission="owner"`
* `sort=workspace.slug`

Note that the query parameter values need to be URL escaped so that `=`
would become `%3D`.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return WorkspacesApiApiUserPermissionsWorkspacesGetRequest
 */
func (a *WorkspacesApiService) UserPermissionsWorkspacesGet(ctx _context.Context) WorkspacesApiApiUserPermissionsWorkspacesGetRequest {
	return WorkspacesApiApiUserPermissionsWorkspacesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return PaginatedWorkspaceMemberships
 */
func (a *WorkspacesApiService) UserPermissionsWorkspacesGetExecute(r WorkspacesApiApiUserPermissionsWorkspacesGetRequest) (PaginatedWorkspaceMemberships, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedWorkspaceMemberships
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.UserPermissionsWorkspacesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/permissions/workspaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	role *string
	q *string
	sort *string
}

func (r WorkspacesApiApiWorkspacesGetRequest) Role(role string) WorkspacesApiApiWorkspacesGetRequest {
	r.role = &role
	return r
}
func (r WorkspacesApiApiWorkspacesGetRequest) Q(q string) WorkspacesApiApiWorkspacesGetRequest {
	r.q = &q
	return r
}
func (r WorkspacesApiApiWorkspacesGetRequest) Sort(sort string) WorkspacesApiApiWorkspacesGetRequest {
	r.sort = &sort
	return r
}

func (r WorkspacesApiApiWorkspacesGetRequest) Execute() (PaginatedWorkspaces, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesGetExecute(r)
}

/*
 * WorkspacesGet Method for WorkspacesGet
 * Returns a list of workspaces accessible by the authenticated user.

Example:

```
$ curl https://api.bitbucket.org/2.0/workspaces

{
  "pagelen": 10,
  "page": 1,
  "size": 1,
  "values": [
    {
        "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
        "links": {
            "owners": {
                "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1/members?q=permission%3D%22owner%22"
            },
            "self": {
                "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1"
            },
            "repositories": {
                "href": "https://api.bitbucket.org/2.0/repositories/bbworkspace1"
            },
            "snippets": {
                "href": "https://api.bitbucket.org/2.0/snippets/bbworkspace1"
            },
            "html": {
                "href": "https://bitbucket.org/bbworkspace1/"
            },
            "avatar": {
                "href": "https://bitbucket.org/workspaces/bbworkspace1/avatar/?ts=1543465801"
            },
            "members": {
                "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1/members"
            },
            "projects": {
                "href": "https://api.bitbucket.org/2.0/workspaces/bbworkspace1/projects"
            }
        },
        "created_on": "2018-11-14T19:15:05.058566+00:00",
        "type": "workspace",
        "slug": "bbworkspace1",
        "is_private": true,
        "name": "Atlassian Bitbucket"
    }
  ]
}
```

Results may be further [filtered or sorted](../meta/filtering) by
workspace or permission by adding the following query string parameters:

* `q=slug="bbworkspace1"` or `q=is_private=true`
* `sort=created_on`

Note that the query parameter values need to be URL escaped so that `=`
would become `%3D`.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return WorkspacesApiApiWorkspacesGetRequest
 */
func (a *WorkspacesApiService) WorkspacesGet(ctx _context.Context) WorkspacesApiApiWorkspacesGetRequest {
	return WorkspacesApiApiWorkspacesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return PaginatedWorkspaces
 */
func (a *WorkspacesApiService) WorkspacesGetExecute(r WorkspacesApiApiWorkspacesGetRequest) (PaginatedWorkspaces, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedWorkspaces
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspaceGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	workspace string
}


func (r WorkspacesApiApiWorkspacesWorkspaceGetRequest) Execute() (Workspace, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspaceGetExecute(r)
}

/*
 * WorkspacesWorkspaceGet Method for WorkspacesWorkspaceGet
 * Returns the requested workspace.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspaceGetRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspaceGetRequest {
	return WorkspacesApiApiWorkspacesWorkspaceGetRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Workspace
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceGetExecute(r WorkspacesApiApiWorkspacesWorkspaceGetRequest) (Workspace, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspaceGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspaceHooksGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	workspace string
}


func (r WorkspacesApiApiWorkspacesWorkspaceHooksGetRequest) Execute() (PaginatedWebhookSubscriptions, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspaceHooksGetExecute(r)
}

/*
 * WorkspacesWorkspaceHooksGet Method for WorkspacesWorkspaceHooksGet
 * Returns a paginated list of webhooks installed on this workspace.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspaceHooksGetRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceHooksGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspaceHooksGetRequest {
	return WorkspacesApiApiWorkspacesWorkspaceHooksGetRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedWebhookSubscriptions
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceHooksGetExecute(r WorkspacesApiApiWorkspacesWorkspaceHooksGetRequest) (PaginatedWebhookSubscriptions, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedWebhookSubscriptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspaceHooksGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/hooks"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspaceHooksPostRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	workspace string
}


func (r WorkspacesApiApiWorkspacesWorkspaceHooksPostRequest) Execute() (WebhookSubscription, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspaceHooksPostExecute(r)
}

/*
 * WorkspacesWorkspaceHooksPost Method for WorkspacesWorkspaceHooksPost
 * Creates a new webhook on the specified workspace.

Workspace webhooks are fired for events from all repositories contained
by that workspace.

Note that only owners can install webhooks on workspaces.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspaceHooksPostRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceHooksPost(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspaceHooksPostRequest {
	return WorkspacesApiApiWorkspacesWorkspaceHooksPostRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return WebhookSubscription
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceHooksPostExecute(r WorkspacesApiApiWorkspacesWorkspaceHooksPostRequest) (WebhookSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WebhookSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspaceHooksPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/hooks"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspaceHooksUidDeleteRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	uid string
	workspace string
}


func (r WorkspacesApiApiWorkspacesWorkspaceHooksUidDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspaceHooksUidDeleteExecute(r)
}

/*
 * WorkspacesWorkspaceHooksUidDelete Method for WorkspacesWorkspaceHooksUidDelete
 * Deletes the specified webhook subscription from the given workspace.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uid Installed webhook's ID
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspaceHooksUidDeleteRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceHooksUidDelete(ctx _context.Context, uid string, workspace string) WorkspacesApiApiWorkspacesWorkspaceHooksUidDeleteRequest {
	return WorkspacesApiApiWorkspacesWorkspaceHooksUidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		uid: uid,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceHooksUidDeleteExecute(r WorkspacesApiApiWorkspacesWorkspaceHooksUidDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspaceHooksUidDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/hooks/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", _neturl.PathEscape(parameterToString(r.uid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspaceHooksUidGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	uid string
	workspace string
}


func (r WorkspacesApiApiWorkspacesWorkspaceHooksUidGetRequest) Execute() (WebhookSubscription, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspaceHooksUidGetExecute(r)
}

/*
 * WorkspacesWorkspaceHooksUidGet Method for WorkspacesWorkspaceHooksUidGet
 * Returns the webhook with the specified id installed on the given
workspace.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uid Installed webhook's ID
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspaceHooksUidGetRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceHooksUidGet(ctx _context.Context, uid string, workspace string) WorkspacesApiApiWorkspacesWorkspaceHooksUidGetRequest {
	return WorkspacesApiApiWorkspacesWorkspaceHooksUidGetRequest{
		ApiService: a,
		ctx: ctx,
		uid: uid,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return WebhookSubscription
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceHooksUidGetExecute(r WorkspacesApiApiWorkspacesWorkspaceHooksUidGetRequest) (WebhookSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WebhookSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspaceHooksUidGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/hooks/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", _neturl.PathEscape(parameterToString(r.uid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspaceHooksUidPutRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	uid string
	workspace string
}


func (r WorkspacesApiApiWorkspacesWorkspaceHooksUidPutRequest) Execute() (WebhookSubscription, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspaceHooksUidPutExecute(r)
}

/*
 * WorkspacesWorkspaceHooksUidPut Method for WorkspacesWorkspaceHooksUidPut
 * Updates the specified webhook subscription.

The following properties can be mutated:

* `description`
* `url`
* `active`
* `events`
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uid Installed webhook's ID
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspaceHooksUidPutRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceHooksUidPut(ctx _context.Context, uid string, workspace string) WorkspacesApiApiWorkspacesWorkspaceHooksUidPutRequest {
	return WorkspacesApiApiWorkspacesWorkspaceHooksUidPutRequest{
		ApiService: a,
		ctx: ctx,
		uid: uid,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return WebhookSubscription
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceHooksUidPutExecute(r WorkspacesApiApiWorkspacesWorkspaceHooksUidPutRequest) (WebhookSubscription, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WebhookSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspaceHooksUidPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/hooks/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", _neturl.PathEscape(parameterToString(r.uid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspaceMembersGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	workspace string
}


func (r WorkspacesApiApiWorkspacesWorkspaceMembersGetRequest) Execute() (PaginatedWorkspaceMemberships, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspaceMembersGetExecute(r)
}

/*
 * WorkspacesWorkspaceMembersGet Method for WorkspacesWorkspaceMembersGet
 * Returns all members of the requested workspace.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspaceMembersGetRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceMembersGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspaceMembersGetRequest {
	return WorkspacesApiApiWorkspacesWorkspaceMembersGetRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedWorkspaceMemberships
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceMembersGetExecute(r WorkspacesApiApiWorkspacesWorkspaceMembersGetRequest) (PaginatedWorkspaceMemberships, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedWorkspaceMemberships
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspaceMembersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspaceMembersMemberGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	member string
	workspace string
}


func (r WorkspacesApiApiWorkspacesWorkspaceMembersMemberGetRequest) Execute() (WorkspaceMembership, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspaceMembersMemberGetExecute(r)
}

/*
 * WorkspacesWorkspaceMembersMemberGet Method for WorkspacesWorkspaceMembersMemberGet
 * Returns the workspace membership, which includes
a `User` object for the member and a `Workspace` object
for the requested workspace.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param member Member's UUID or Atlassian ID.
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspaceMembersMemberGetRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceMembersMemberGet(ctx _context.Context, member string, workspace string) WorkspacesApiApiWorkspacesWorkspaceMembersMemberGetRequest {
	return WorkspacesApiApiWorkspacesWorkspaceMembersMemberGetRequest{
		ApiService: a,
		ctx: ctx,
		member: member,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return WorkspaceMembership
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceMembersMemberGetExecute(r WorkspacesApiApiWorkspacesWorkspaceMembersMemberGetRequest) (WorkspaceMembership, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WorkspaceMembership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspaceMembersMemberGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/members/{member}"
	localVarPath = strings.Replace(localVarPath, "{"+"member"+"}", _neturl.PathEscape(parameterToString(r.member, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspacePermissionsGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	workspace string
	q *string
}

func (r WorkspacesApiApiWorkspacesWorkspacePermissionsGetRequest) Q(q string) WorkspacesApiApiWorkspacesWorkspacePermissionsGetRequest {
	r.q = &q
	return r
}

func (r WorkspacesApiApiWorkspacesWorkspacePermissionsGetRequest) Execute() (PaginatedWorkspaceMemberships, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspacePermissionsGetExecute(r)
}

/*
 * WorkspacesWorkspacePermissionsGet Method for WorkspacesWorkspacePermissionsGet
 * Returns the list of members in a workspace
and their permission levels.
Permission can be:
* `owner`
* `collaborator`
* `member`

Example:

```
$ curl -X https://api.bitbucket.org/2.0/workspaces/bbworkspace1/permissions

{
    "pagelen": 10,
    "values": [
        {
            "permission": "owner",
            "type": "workspace_membership",
            "user": {
                "type": "user",
                "uuid": "{470c176d-3574-44ea-bb41-89e8638bcca4}",
                "display_name": "Erik van Zijst",
            },
            "workspace": {
                "type": "workspace",
                "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
                "slug": "bbworkspace1",
                "name": "Atlassian Bitbucket",
            }
        },
        {
            "permission": "member",
            "type": "workspace_membership",
            "user": {
                "type": "user",
                "nickname": "seanaty",
                "display_name": "Sean Conaty",
                "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
            },
            "workspace": {
                "type": "workspace",
                "uuid": "{a15fb181-db1f-48f7-b41f-e1eff06929d6}",
                "slug": "bbworkspace1",
                "name": "Atlassian Bitbucket",
            }
        }
    ],
    "page": 1,
    "size": 2
}
```

Results may be further [filtered](../../../meta/filtering) by
permission by adding the following query string parameters:

* `q=permission="owner"`
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspacePermissionsGetRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspacePermissionsGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspacePermissionsGetRequest {
	return WorkspacesApiApiWorkspacesWorkspacePermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedWorkspaceMemberships
 */
func (a *WorkspacesApiService) WorkspacesWorkspacePermissionsGetExecute(r WorkspacesApiApiWorkspacesWorkspacePermissionsGetRequest) (PaginatedWorkspaceMemberships, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedWorkspaceMemberships
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspacePermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	workspace string
	q *string
	sort *string
}

func (r WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest) Q(q string) WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest {
	r.q = &q
	return r
}
func (r WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest) Sort(sort string) WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest {
	r.sort = &sort
	return r
}

func (r WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest) Execute() (PaginatedRepositoryPermissions, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspacePermissionsRepositoriesGetExecute(r)
}

/*
 * WorkspacesWorkspacePermissionsRepositoriesGet Method for WorkspacesWorkspacePermissionsRepositoriesGet
 * Returns an object for each repository permission for all of a
workspace's repositories.

Permissions returned are effective permissions: the highest level of
permission the user has. This does not distinguish between direct and
indirect (group) privileges.

Only users with admin permission for the team may access this resource.

Permissions can be:

* `admin`
* `write`
* `read`

Example:

```
$ curl https://api.bitbucket.org/2.0/workspaces/atlassian_tutorial/permissions/repositories

{
  "pagelen": 10,
  "values": [
    {
      "type": "repository_permission",
      "user": {
        "type": "user",
        "display_name": "Erik van Zijst",
        "uuid": "{d301aafa-d676-4ee0-88be-962be7417567}"
      },
      "repository": {
        "type": "repository",
        "name": "geordi",
        "full_name": "atlassian_tutorial/geordi",
        "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
      },
      "permission": "admin"
    },
    {
      "type": "repository_permission",
      "user": {
        "type": "user",
        "display_name": "Sean Conaty",
        "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
      },
      "repository": {
        "type": "repository",
        "name": "geordi",
        "full_name": "atlassian_tutorial/geordi",
        "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
      },
      "permission": "write"
    },
    {
      "type": "repository_permission",
      "user": {
        "type": "user",
        "display_name": "Jeff Zeng",
        "uuid": "{47f92a9a-c3a3-4d0b-bc4e-782a969c5c72}"
      },
      "repository": {
        "type": "repository",
        "name": "whee",
        "full_name": "atlassian_tutorial/whee",
        "uuid": "{30ba25e9-51ff-4555-8dd0-fc7ee2fa0895}"
      },
      "permission": "admin"
    }
  ],
  "page": 1,
  "size": 3
}
```

Results may be further [filtered or sorted](../../../../meta/filtering)
by repository, user, or permission by adding the following query string
parameters:

* `q=repository.name="geordi"` or `q=permission>"read"`
* `sort=user.display_name`

Note that the query parameter values need to be URL escaped so that `=`
would become `%3D`.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspacePermissionsRepositoriesGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest {
	return WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedRepositoryPermissions
 */
func (a *WorkspacesApiService) WorkspacesWorkspacePermissionsRepositoriesGetExecute(r WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesGetRequest) (PaginatedRepositoryPermissions, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedRepositoryPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspacePermissionsRepositoriesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/permissions/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	repoSlug string
	workspace string
	q *string
	sort *string
}

func (r WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest) Q(q string) WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest {
	r.q = &q
	return r
}
func (r WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest) Sort(sort string) WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest {
	r.sort = &sort
	return r
}

func (r WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest) Execute() (PaginatedRepositoryPermissions, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspacePermissionsRepositoriesRepoSlugGetExecute(r)
}

/*
 * WorkspacesWorkspacePermissionsRepositoriesRepoSlugGet Method for WorkspacesWorkspacePermissionsRepositoriesRepoSlugGet
 * Returns an object for the repository permission of each user in the
requested repository.

Permissions returned are effective permissions: the highest level of
permission the user has. This does not distinguish between direct and
indirect (group) privileges.

Only users with admin permission for the repository may access this resource.

Permissions can be:

* `admin`
* `write`
* `read`

Example:

```
$ curl https://api.bitbucket.org/2.0/workspaces/atlassian_tutorial/permissions/repositories/geordi

{
  "pagelen": 10,
  "values": [
    {
      "type": "repository_permission",
      "user": {
        "type": "user",
        "display_name": "Erik van Zijst",
        "uuid": "{d301aafa-d676-4ee0-88be-962be7417567}"
      },
      "repository": {
        "type": "repository",
        "name": "geordi",
        "full_name": "atlassian_tutorial/geordi",
        "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
      },
      "permission": "admin"
    },
    {
      "type": "repository_permission",
      "user": {
        "type": "user",
        "display_name": "Sean Conaty",
        "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
      },
      "repository": {
        "type": "repository",
        "name": "geordi",
        "full_name": "atlassian_tutorial/geordi",
        "uuid": "{85d08b4e-571d-44e9-a507-fa476535aa98}"
      },
      "permission": "write"
    }
  ],
  "page": 1,
  "size": 2
}
```

Results may be further [filtered or sorted](../../../../meta/filtering)
by user, or permission by adding the following query string parameters:

* `q=permission>"read"`
* `sort=user.display_name`

Note that the query parameter values need to be URL escaped so that `=`
would become `%3D`.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspacePermissionsRepositoriesRepoSlugGet(ctx _context.Context, repoSlug string, workspace string) WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest {
	return WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedRepositoryPermissions
 */
func (a *WorkspacesApiService) WorkspacesWorkspacePermissionsRepositoriesRepoSlugGetExecute(r WorkspacesApiApiWorkspacesWorkspacePermissionsRepositoriesRepoSlugGetRequest) (PaginatedRepositoryPermissions, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedRepositoryPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspacePermissionsRepositoriesRepoSlugGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/permissions/repositories/{repo_slug}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspaceProjectsGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	workspace string
}


func (r WorkspacesApiApiWorkspacesWorkspaceProjectsGetRequest) Execute() (PaginatedProjects, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspaceProjectsGetExecute(r)
}

/*
 * WorkspacesWorkspaceProjectsGet Method for WorkspacesWorkspaceProjectsGet
 * Returns the list of projects in this workspace.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspaceProjectsGetRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceProjectsGet(ctx _context.Context, workspace string) WorkspacesApiApiWorkspacesWorkspaceProjectsGetRequest {
	return WorkspacesApiApiWorkspacesWorkspaceProjectsGetRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedProjects
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceProjectsGetExecute(r WorkspacesApiApiWorkspacesWorkspaceProjectsGetRequest) (PaginatedProjects, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedProjects
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspaceProjectsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/projects"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkspacesApiApiWorkspacesWorkspaceProjectsProjectKeyGetRequest struct {
	ctx _context.Context
	ApiService WorkspacesApi
	projectKey string
	workspace string
}


func (r WorkspacesApiApiWorkspacesWorkspaceProjectsProjectKeyGetRequest) Execute() (Project, *_nethttp.Response, error) {
	return r.ApiService.WorkspacesWorkspaceProjectsProjectKeyGetExecute(r)
}

/*
 * WorkspacesWorkspaceProjectsProjectKeyGet Method for WorkspacesWorkspaceProjectsProjectKeyGet
 * Returns the requested project.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectKey The project in question. This is the actual `key` assigned to the project. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return WorkspacesApiApiWorkspacesWorkspaceProjectsProjectKeyGetRequest
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceProjectsProjectKeyGet(ctx _context.Context, projectKey string, workspace string) WorkspacesApiApiWorkspacesWorkspaceProjectsProjectKeyGetRequest {
	return WorkspacesApiApiWorkspacesWorkspaceProjectsProjectKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		projectKey: projectKey,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Project
 */
func (a *WorkspacesApiService) WorkspacesWorkspaceProjectsProjectKeyGetExecute(r WorkspacesApiApiWorkspacesWorkspaceProjectsProjectKeyGetRequest) (Project, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Project
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkspacesApiService.WorkspacesWorkspaceProjectsProjectKeyGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/projects/{project_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_key"+"}", _neturl.PathEscape(parameterToString(r.projectKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
