/*
 * Bitbucket API
 *
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * API version: 2.0
 * Contact: support@bitbucket.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bitbucket_client

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type AddonApi interface {

	/*
	 * AddonDelete Method for AddonDelete
	 * Deletes the application for the user.

This endpoint is intended to be used by Bitbucket Connect apps
and only supports JWT authentication -- that is how Bitbucket
identifies the particular installation of the app. Developers
with applications registered in the "Develop Apps" section
of Bitbucket Marketplace need not use this endpoint as
updates for those applications can be sent out via the
UI of that section.

```
$ curl -X DELETE https://api.bitbucket.org/2.0/addon \
  -H "Authorization: JWT <JWT Token>"
```
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return AddonApiApiAddonDeleteRequest
	 */
	AddonDelete(ctx _context.Context) AddonApiApiAddonDeleteRequest

	/*
	 * AddonDeleteExecute executes the request
	 */
	AddonDeleteExecute(r AddonApiApiAddonDeleteRequest) (*_nethttp.Response, error)

	/*
	 * AddonLinkersGet Method for AddonLinkersGet
	 * Gets a list of all [linkers](/cloud/bitbucket/modules/linker/)
for the authenticated application.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return AddonApiApiAddonLinkersGetRequest
	 */
	AddonLinkersGet(ctx _context.Context) AddonApiApiAddonLinkersGetRequest

	/*
	 * AddonLinkersGetExecute executes the request
	 */
	AddonLinkersGetExecute(r AddonApiApiAddonLinkersGetRequest) (*_nethttp.Response, error)

	/*
	 * AddonLinkersLinkerKeyGet Method for AddonLinkersLinkerKeyGet
	 * Gets a [linker](/cloud/bitbucket/modules/linker/) specified by `linker_key`
for the authenticated application.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
	 * @return AddonApiApiAddonLinkersLinkerKeyGetRequest
	 */
	AddonLinkersLinkerKeyGet(ctx _context.Context, linkerKey string) AddonApiApiAddonLinkersLinkerKeyGetRequest

	/*
	 * AddonLinkersLinkerKeyGetExecute executes the request
	 */
	AddonLinkersLinkerKeyGetExecute(r AddonApiApiAddonLinkersLinkerKeyGetRequest) (*_nethttp.Response, error)

	/*
	 * AddonLinkersLinkerKeyValuesDelete Method for AddonLinkersLinkerKeyValuesDelete
	 * Delete all [linker](/cloud/bitbucket/modules/linker/) values for the
specified linker of the authenticated application.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
	 * @return AddonApiApiAddonLinkersLinkerKeyValuesDeleteRequest
	 */
	AddonLinkersLinkerKeyValuesDelete(ctx _context.Context, linkerKey string) AddonApiApiAddonLinkersLinkerKeyValuesDeleteRequest

	/*
	 * AddonLinkersLinkerKeyValuesDeleteExecute executes the request
	 */
	AddonLinkersLinkerKeyValuesDeleteExecute(r AddonApiApiAddonLinkersLinkerKeyValuesDeleteRequest) (*_nethttp.Response, error)

	/*
	 * AddonLinkersLinkerKeyValuesGet Method for AddonLinkersLinkerKeyValuesGet
	 * Gets a list of all [linker](/cloud/bitbucket/modules/linker/) values for the
specified linker of the authenticated application.

A linker value lets applications supply values to modify its regular expression.

The base regular expression must use a Bitbucket-specific match group `(?K)`
which will be translated to `([\w\-]+)`. A value must match this pattern.

[Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
	 * @return AddonApiApiAddonLinkersLinkerKeyValuesGetRequest
	 */
	AddonLinkersLinkerKeyValuesGet(ctx _context.Context, linkerKey string) AddonApiApiAddonLinkersLinkerKeyValuesGetRequest

	/*
	 * AddonLinkersLinkerKeyValuesGetExecute executes the request
	 */
	AddonLinkersLinkerKeyValuesGetExecute(r AddonApiApiAddonLinkersLinkerKeyValuesGetRequest) (*_nethttp.Response, error)

	/*
	 * AddonLinkersLinkerKeyValuesPost Method for AddonLinkersLinkerKeyValuesPost
	 * Creates a [linker](/cloud/bitbucket/modules/linker/) value for the specified
linker of authenticated application.

A linker value lets applications supply values to modify its regular expression.

The base regular expression must use a Bitbucket-specific match group `(?K)`
which will be translated to `([\w\-]+)`. A value must match this pattern.

[Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
	 * @return AddonApiApiAddonLinkersLinkerKeyValuesPostRequest
	 */
	AddonLinkersLinkerKeyValuesPost(ctx _context.Context, linkerKey string) AddonApiApiAddonLinkersLinkerKeyValuesPostRequest

	/*
	 * AddonLinkersLinkerKeyValuesPostExecute executes the request
	 */
	AddonLinkersLinkerKeyValuesPostExecute(r AddonApiApiAddonLinkersLinkerKeyValuesPostRequest) (*_nethttp.Response, error)

	/*
	 * AddonLinkersLinkerKeyValuesPut Method for AddonLinkersLinkerKeyValuesPut
	 * Bulk update [linker](/cloud/bitbucket/modules/linker/) values for the specified
linker of the authenticated application.

A linker value lets applications supply values to modify its regular expression.

The base regular expression must use a Bitbucket-specific match group `(?K)`
which will be translated to `([\w\-]+)`. A value must match this pattern.

[Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
	 * @return AddonApiApiAddonLinkersLinkerKeyValuesPutRequest
	 */
	AddonLinkersLinkerKeyValuesPut(ctx _context.Context, linkerKey string) AddonApiApiAddonLinkersLinkerKeyValuesPutRequest

	/*
	 * AddonLinkersLinkerKeyValuesPutExecute executes the request
	 */
	AddonLinkersLinkerKeyValuesPutExecute(r AddonApiApiAddonLinkersLinkerKeyValuesPutRequest) (*_nethttp.Response, error)

	/*
	 * AddonLinkersLinkerKeyValuesValueIdDelete Method for AddonLinkersLinkerKeyValuesValueIdDelete
	 * Delete a single [linker](/cloud/bitbucket/modules/linker/) value
of the authenticated application.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
	 * @param valueId The numeric ID of the linker value.
	 * @return AddonApiApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest
	 */
	AddonLinkersLinkerKeyValuesValueIdDelete(ctx _context.Context, linkerKey string, valueId int32) AddonApiApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest

	/*
	 * AddonLinkersLinkerKeyValuesValueIdDeleteExecute executes the request
	 */
	AddonLinkersLinkerKeyValuesValueIdDeleteExecute(r AddonApiApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * AddonLinkersLinkerKeyValuesValueIdGet Method for AddonLinkersLinkerKeyValuesValueIdGet
	 * Get a single [linker](/cloud/bitbucket/modules/linker/) value
of the authenticated application.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
	 * @param valueId The numeric ID of the linker value.
	 * @return AddonApiApiAddonLinkersLinkerKeyValuesValueIdGetRequest
	 */
	AddonLinkersLinkerKeyValuesValueIdGet(ctx _context.Context, linkerKey string, valueId int32) AddonApiApiAddonLinkersLinkerKeyValuesValueIdGetRequest

	/*
	 * AddonLinkersLinkerKeyValuesValueIdGetExecute executes the request
	 */
	AddonLinkersLinkerKeyValuesValueIdGetExecute(r AddonApiApiAddonLinkersLinkerKeyValuesValueIdGetRequest) (*_nethttp.Response, error)

	/*
	 * AddonPut Method for AddonPut
	 * Updates the application installation for the user.

This endpoint is intended to be used by Bitbucket Connect apps
and only supports JWT authentication -- that is how Bitbucket
identifies the particular installation of the app. Developers
with applications registered in the "Develop Apps" section
of Bitbucket Marketplace need not use this endpoint as
updates for those applications can be sent out via the
UI of that section.

A new, valid descriptor must be provided in the body of the
PUT request.

```
$ curl -X PUT https://api.bitbucket.org/2.0/addon \
  -H "Authorization: JWT <JWT Token>" \
  --header "Content-Type: application/json" \
  --data '{"descriptor": $NEW_DESCRIPTOR}'
```

Note that the scopes of the application cannot be increased
in the new descriptor nor reduced to none.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return AddonApiApiAddonPutRequest
	 */
	AddonPut(ctx _context.Context) AddonApiApiAddonPutRequest

	/*
	 * AddonPutExecute executes the request
	 */
	AddonPutExecute(r AddonApiApiAddonPutRequest) (*_nethttp.Response, error)
}

// AddonApiService AddonApi service
type AddonApiService service

type AddonApiApiAddonDeleteRequest struct {
	ctx _context.Context
	ApiService AddonApi
}


func (r AddonApiApiAddonDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddonDeleteExecute(r)
}

/*
 * AddonDelete Method for AddonDelete
 * Deletes the application for the user.

This endpoint is intended to be used by Bitbucket Connect apps
and only supports JWT authentication -- that is how Bitbucket
identifies the particular installation of the app. Developers
with applications registered in the "Develop Apps" section
of Bitbucket Marketplace need not use this endpoint as
updates for those applications can be sent out via the
UI of that section.

```
$ curl -X DELETE https://api.bitbucket.org/2.0/addon \
  -H "Authorization: JWT <JWT Token>"
```
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return AddonApiApiAddonDeleteRequest
 */
func (a *AddonApiService) AddonDelete(ctx _context.Context) AddonApiApiAddonDeleteRequest {
	return AddonApiApiAddonDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AddonApiService) AddonDeleteExecute(r AddonApiApiAddonDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddonApiService.AddonDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addon"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AddonApiApiAddonLinkersGetRequest struct {
	ctx _context.Context
	ApiService AddonApi
}


func (r AddonApiApiAddonLinkersGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddonLinkersGetExecute(r)
}

/*
 * AddonLinkersGet Method for AddonLinkersGet
 * Gets a list of all [linkers](/cloud/bitbucket/modules/linker/)
for the authenticated application.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return AddonApiApiAddonLinkersGetRequest
 */
func (a *AddonApiService) AddonLinkersGet(ctx _context.Context) AddonApiApiAddonLinkersGetRequest {
	return AddonApiApiAddonLinkersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AddonApiService) AddonLinkersGetExecute(r AddonApiApiAddonLinkersGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddonApiService.AddonLinkersGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addon/linkers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AddonApiApiAddonLinkersLinkerKeyGetRequest struct {
	ctx _context.Context
	ApiService AddonApi
	linkerKey string
}


func (r AddonApiApiAddonLinkersLinkerKeyGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddonLinkersLinkerKeyGetExecute(r)
}

/*
 * AddonLinkersLinkerKeyGet Method for AddonLinkersLinkerKeyGet
 * Gets a [linker](/cloud/bitbucket/modules/linker/) specified by `linker_key`
for the authenticated application.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
 * @return AddonApiApiAddonLinkersLinkerKeyGetRequest
 */
func (a *AddonApiService) AddonLinkersLinkerKeyGet(ctx _context.Context, linkerKey string) AddonApiApiAddonLinkersLinkerKeyGetRequest {
	return AddonApiApiAddonLinkersLinkerKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		linkerKey: linkerKey,
	}
}

/*
 * Execute executes the request
 */
func (a *AddonApiService) AddonLinkersLinkerKeyGetExecute(r AddonApiApiAddonLinkersLinkerKeyGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddonApiService.AddonLinkersLinkerKeyGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addon/linkers/{linker_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"linker_key"+"}", _neturl.PathEscape(parameterToString(r.linkerKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AddonApiApiAddonLinkersLinkerKeyValuesDeleteRequest struct {
	ctx _context.Context
	ApiService AddonApi
	linkerKey string
}


func (r AddonApiApiAddonLinkersLinkerKeyValuesDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddonLinkersLinkerKeyValuesDeleteExecute(r)
}

/*
 * AddonLinkersLinkerKeyValuesDelete Method for AddonLinkersLinkerKeyValuesDelete
 * Delete all [linker](/cloud/bitbucket/modules/linker/) values for the
specified linker of the authenticated application.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
 * @return AddonApiApiAddonLinkersLinkerKeyValuesDeleteRequest
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesDelete(ctx _context.Context, linkerKey string) AddonApiApiAddonLinkersLinkerKeyValuesDeleteRequest {
	return AddonApiApiAddonLinkersLinkerKeyValuesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		linkerKey: linkerKey,
	}
}

/*
 * Execute executes the request
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesDeleteExecute(r AddonApiApiAddonLinkersLinkerKeyValuesDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddonApiService.AddonLinkersLinkerKeyValuesDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addon/linkers/{linker_key}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"linker_key"+"}", _neturl.PathEscape(parameterToString(r.linkerKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AddonApiApiAddonLinkersLinkerKeyValuesGetRequest struct {
	ctx _context.Context
	ApiService AddonApi
	linkerKey string
}


func (r AddonApiApiAddonLinkersLinkerKeyValuesGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddonLinkersLinkerKeyValuesGetExecute(r)
}

/*
 * AddonLinkersLinkerKeyValuesGet Method for AddonLinkersLinkerKeyValuesGet
 * Gets a list of all [linker](/cloud/bitbucket/modules/linker/) values for the
specified linker of the authenticated application.

A linker value lets applications supply values to modify its regular expression.

The base regular expression must use a Bitbucket-specific match group `(?K)`
which will be translated to `([\w\-]+)`. A value must match this pattern.

[Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
 * @return AddonApiApiAddonLinkersLinkerKeyValuesGetRequest
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesGet(ctx _context.Context, linkerKey string) AddonApiApiAddonLinkersLinkerKeyValuesGetRequest {
	return AddonApiApiAddonLinkersLinkerKeyValuesGetRequest{
		ApiService: a,
		ctx: ctx,
		linkerKey: linkerKey,
	}
}

/*
 * Execute executes the request
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesGetExecute(r AddonApiApiAddonLinkersLinkerKeyValuesGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddonApiService.AddonLinkersLinkerKeyValuesGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addon/linkers/{linker_key}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"linker_key"+"}", _neturl.PathEscape(parameterToString(r.linkerKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AddonApiApiAddonLinkersLinkerKeyValuesPostRequest struct {
	ctx _context.Context
	ApiService AddonApi
	linkerKey string
}


func (r AddonApiApiAddonLinkersLinkerKeyValuesPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddonLinkersLinkerKeyValuesPostExecute(r)
}

/*
 * AddonLinkersLinkerKeyValuesPost Method for AddonLinkersLinkerKeyValuesPost
 * Creates a [linker](/cloud/bitbucket/modules/linker/) value for the specified
linker of authenticated application.

A linker value lets applications supply values to modify its regular expression.

The base regular expression must use a Bitbucket-specific match group `(?K)`
which will be translated to `([\w\-]+)`. A value must match this pattern.

[Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
 * @return AddonApiApiAddonLinkersLinkerKeyValuesPostRequest
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesPost(ctx _context.Context, linkerKey string) AddonApiApiAddonLinkersLinkerKeyValuesPostRequest {
	return AddonApiApiAddonLinkersLinkerKeyValuesPostRequest{
		ApiService: a,
		ctx: ctx,
		linkerKey: linkerKey,
	}
}

/*
 * Execute executes the request
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesPostExecute(r AddonApiApiAddonLinkersLinkerKeyValuesPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddonApiService.AddonLinkersLinkerKeyValuesPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addon/linkers/{linker_key}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"linker_key"+"}", _neturl.PathEscape(parameterToString(r.linkerKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AddonApiApiAddonLinkersLinkerKeyValuesPutRequest struct {
	ctx _context.Context
	ApiService AddonApi
	linkerKey string
}


func (r AddonApiApiAddonLinkersLinkerKeyValuesPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddonLinkersLinkerKeyValuesPutExecute(r)
}

/*
 * AddonLinkersLinkerKeyValuesPut Method for AddonLinkersLinkerKeyValuesPut
 * Bulk update [linker](/cloud/bitbucket/modules/linker/) values for the specified
linker of the authenticated application.

A linker value lets applications supply values to modify its regular expression.

The base regular expression must use a Bitbucket-specific match group `(?K)`
which will be translated to `([\w\-]+)`. A value must match this pattern.

[Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
 * @return AddonApiApiAddonLinkersLinkerKeyValuesPutRequest
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesPut(ctx _context.Context, linkerKey string) AddonApiApiAddonLinkersLinkerKeyValuesPutRequest {
	return AddonApiApiAddonLinkersLinkerKeyValuesPutRequest{
		ApiService: a,
		ctx: ctx,
		linkerKey: linkerKey,
	}
}

/*
 * Execute executes the request
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesPutExecute(r AddonApiApiAddonLinkersLinkerKeyValuesPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddonApiService.AddonLinkersLinkerKeyValuesPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addon/linkers/{linker_key}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"linker_key"+"}", _neturl.PathEscape(parameterToString(r.linkerKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AddonApiApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest struct {
	ctx _context.Context
	ApiService AddonApi
	linkerKey string
	valueId int32
}


func (r AddonApiApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddonLinkersLinkerKeyValuesValueIdDeleteExecute(r)
}

/*
 * AddonLinkersLinkerKeyValuesValueIdDelete Method for AddonLinkersLinkerKeyValuesValueIdDelete
 * Delete a single [linker](/cloud/bitbucket/modules/linker/) value
of the authenticated application.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
 * @param valueId The numeric ID of the linker value.
 * @return AddonApiApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesValueIdDelete(ctx _context.Context, linkerKey string, valueId int32) AddonApiApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest {
	return AddonApiApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		linkerKey: linkerKey,
		valueId: valueId,
	}
}

/*
 * Execute executes the request
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesValueIdDeleteExecute(r AddonApiApiAddonLinkersLinkerKeyValuesValueIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddonApiService.AddonLinkersLinkerKeyValuesValueIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addon/linkers/{linker_key}/values/{value_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"linker_key"+"}", _neturl.PathEscape(parameterToString(r.linkerKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"value_id"+"}", _neturl.PathEscape(parameterToString(r.valueId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AddonApiApiAddonLinkersLinkerKeyValuesValueIdGetRequest struct {
	ctx _context.Context
	ApiService AddonApi
	linkerKey string
	valueId int32
}


func (r AddonApiApiAddonLinkersLinkerKeyValuesValueIdGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddonLinkersLinkerKeyValuesValueIdGetExecute(r)
}

/*
 * AddonLinkersLinkerKeyValuesValueIdGet Method for AddonLinkersLinkerKeyValuesValueIdGet
 * Get a single [linker](/cloud/bitbucket/modules/linker/) value
of the authenticated application.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param linkerKey The unique key of a [linker module](/cloud/bitbucket/modules/linker/) as defined in an application descriptor.
 * @param valueId The numeric ID of the linker value.
 * @return AddonApiApiAddonLinkersLinkerKeyValuesValueIdGetRequest
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesValueIdGet(ctx _context.Context, linkerKey string, valueId int32) AddonApiApiAddonLinkersLinkerKeyValuesValueIdGetRequest {
	return AddonApiApiAddonLinkersLinkerKeyValuesValueIdGetRequest{
		ApiService: a,
		ctx: ctx,
		linkerKey: linkerKey,
		valueId: valueId,
	}
}

/*
 * Execute executes the request
 */
func (a *AddonApiService) AddonLinkersLinkerKeyValuesValueIdGetExecute(r AddonApiApiAddonLinkersLinkerKeyValuesValueIdGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddonApiService.AddonLinkersLinkerKeyValuesValueIdGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addon/linkers/{linker_key}/values/{value_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"linker_key"+"}", _neturl.PathEscape(parameterToString(r.linkerKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"value_id"+"}", _neturl.PathEscape(parameterToString(r.valueId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AddonApiApiAddonPutRequest struct {
	ctx _context.Context
	ApiService AddonApi
}


func (r AddonApiApiAddonPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddonPutExecute(r)
}

/*
 * AddonPut Method for AddonPut
 * Updates the application installation for the user.

This endpoint is intended to be used by Bitbucket Connect apps
and only supports JWT authentication -- that is how Bitbucket
identifies the particular installation of the app. Developers
with applications registered in the "Develop Apps" section
of Bitbucket Marketplace need not use this endpoint as
updates for those applications can be sent out via the
UI of that section.

A new, valid descriptor must be provided in the body of the
PUT request.

```
$ curl -X PUT https://api.bitbucket.org/2.0/addon \
  -H "Authorization: JWT <JWT Token>" \
  --header "Content-Type: application/json" \
  --data '{"descriptor": $NEW_DESCRIPTOR}'
```

Note that the scopes of the application cannot be increased
in the new descriptor nor reduced to none.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return AddonApiApiAddonPutRequest
 */
func (a *AddonApiService) AddonPut(ctx _context.Context) AddonApiApiAddonPutRequest {
	return AddonApiApiAddonPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *AddonApiService) AddonPutExecute(r AddonApiApiAddonPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddonApiService.AddonPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addon"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
