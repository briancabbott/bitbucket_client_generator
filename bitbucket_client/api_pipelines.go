/*
 * Bitbucket API
 *
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * API version: 2.0
 * Contact: support@bitbucket.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bitbucket_client

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type PipelinesApi interface {

	/*
	 * CreateDeploymentVariable Method for CreateDeploymentVariable
	 * Create a deployment environment level variable.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param environmentUuid The environment.
	 * @param variableUuid The UUID of the variable to update.
	 * @return PipelinesApiApiCreateDeploymentVariableRequest
	 */
	CreateDeploymentVariable(ctx _context.Context, workspace string, repoSlug string, environmentUuid string, variableUuid string) PipelinesApiApiCreateDeploymentVariableRequest

	/*
	 * CreateDeploymentVariableExecute executes the request
	 * @return DeploymentVariable
	 */
	CreateDeploymentVariableExecute(r PipelinesApiApiCreateDeploymentVariableRequest) (DeploymentVariable, *_nethttp.Response, error)

	/*
	 * CreatePipelineForRepository Method for CreatePipelineForRepository
	 * Endpoint to create and initiate a pipeline.
There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated.
# Trigger a Pipeline for a branch
One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline.
The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
  -d '
  {
    "target": {
      "ref_type": "branch",
      "type": "pipeline_ref_target",
      "ref_name": "master"
    }
  }'
```
# Trigger a Pipeline for a commit on a branch or tag
You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark).
The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.

The following reference types are supported:

* `branch`
* `named_branch`
* `bookmark`
 * `tag`

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
  -d '
  {
    "target": {
      "commit": {
        "type": "commit",
        "hash": "ce5b7431602f7cbba007062eeb55225c6e18e956"
      },
      "ref_type": "branch",
      "type": "pipeline_ref_target",
      "ref_name": "master"
    }
  }'
```
# Trigger a specific pipeline definition for a commit
You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit.
In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
 -d '
  {
     "target": {
      "commit": {
         "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
         "type":"commit"
       },
        "selector": {
           "type":"custom",
              "pattern":"Deploy to production"
          },
        "type":"pipeline_commit_target"
   }
  }'
```
# Trigger a specific pipeline definition for a commit on a branch or tag
You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference.
In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
 -d '
  {
     "target": {
      "commit": {
         "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
         "type":"commit"
       },
       "selector": {
          "type": "custom",
          "pattern": "Deploy to production"
       },
       "type": "pipeline_ref_target",
       "ref_name": "master",
       "ref_type": "branch"
     }
  }'
```


# Trigger a custom pipeline with variables
In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
 -d '
  {
    "target": {
      "type": "pipeline_ref_target",
      "ref_type": "branch",
      "ref_name": "master",
      "selector": {
        "type": "custom",
        "pattern": "Deploy to production"
      }
    },
    "variables": [
      {
        "key": "var1key",
        "value": "var1value",
        "secured": true
      },
      {
        "key": "var2key",
        "value": "var2value"
      }
    ]
  }'
```

# Trigger a pull request pipeline

You can also initiate a pipeline for a specific pull request.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
 -d '
  {
	"target": {
      "type": "pipeline_pullrequest_target",
	  "source": "pull-request-branch",
      "destination": "master",
      "destination_commit": {
      	 "hash" : "9f848b7"
      },
      "commit": {
      	"hash" : "1a372fc"
      },
      "pullrequest" : {
      	"id" : "3"
      },
	  "selector": {
        "type": "pull-requests",
        "pattern": "**"
      }
    }
  }'
```

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiCreatePipelineForRepositoryRequest
	 */
	CreatePipelineForRepository(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiCreatePipelineForRepositoryRequest

	/*
	 * CreatePipelineForRepositoryExecute executes the request
	 * @return Pipeline
	 */
	CreatePipelineForRepositoryExecute(r PipelinesApiApiCreatePipelineForRepositoryRequest) (Pipeline, *_nethttp.Response, error)

	/*
	 * CreatePipelineVariableForTeam Method for CreatePipelineVariableForTeam
	 * Create an account level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param username This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @return PipelinesApiApiCreatePipelineVariableForTeamRequest
	 */
	CreatePipelineVariableForTeam(ctx _context.Context, username string) PipelinesApiApiCreatePipelineVariableForTeamRequest

	/*
	 * CreatePipelineVariableForTeamExecute executes the request
	 * @return PipelineVariable
	 */
	CreatePipelineVariableForTeamExecute(r PipelinesApiApiCreatePipelineVariableForTeamRequest) (PipelineVariable, *_nethttp.Response, error)

	/*
	 * CreatePipelineVariableForUser Method for CreatePipelineVariableForUser
	 * Create a user level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
	 * @return PipelinesApiApiCreatePipelineVariableForUserRequest
	 */
	CreatePipelineVariableForUser(ctx _context.Context, selectedUser string) PipelinesApiApiCreatePipelineVariableForUserRequest

	/*
	 * CreatePipelineVariableForUserExecute executes the request
	 * @return PipelineVariable
	 */
	CreatePipelineVariableForUserExecute(r PipelinesApiApiCreatePipelineVariableForUserRequest) (PipelineVariable, *_nethttp.Response, error)

	/*
	 * CreatePipelineVariableForWorkspace Method for CreatePipelineVariableForWorkspace
	 * Create a workspace level variable.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @return PipelinesApiApiCreatePipelineVariableForWorkspaceRequest
	 */
	CreatePipelineVariableForWorkspace(ctx _context.Context, workspace string) PipelinesApiApiCreatePipelineVariableForWorkspaceRequest

	/*
	 * CreatePipelineVariableForWorkspaceExecute executes the request
	 * @return PipelineVariable
	 */
	CreatePipelineVariableForWorkspaceExecute(r PipelinesApiApiCreatePipelineVariableForWorkspaceRequest) (PipelineVariable, *_nethttp.Response, error)

	/*
	 * CreateRepositoryPipelineKnownHost Method for CreateRepositoryPipelineKnownHost
	 * Create a repository level known host.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiCreateRepositoryPipelineKnownHostRequest
	 */
	CreateRepositoryPipelineKnownHost(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiCreateRepositoryPipelineKnownHostRequest

	/*
	 * CreateRepositoryPipelineKnownHostExecute executes the request
	 * @return PipelineKnownHost
	 */
	CreateRepositoryPipelineKnownHostExecute(r PipelinesApiApiCreateRepositoryPipelineKnownHostRequest) (PipelineKnownHost, *_nethttp.Response, error)

	/*
	 * CreateRepositoryPipelineSchedule Method for CreateRepositoryPipelineSchedule
	 * Create a schedule for the given repository.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiCreateRepositoryPipelineScheduleRequest
	 */
	CreateRepositoryPipelineSchedule(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiCreateRepositoryPipelineScheduleRequest

	/*
	 * CreateRepositoryPipelineScheduleExecute executes the request
	 * @return PipelineSchedule
	 */
	CreateRepositoryPipelineScheduleExecute(r PipelinesApiApiCreateRepositoryPipelineScheduleRequest) (PipelineSchedule, *_nethttp.Response, error)

	/*
	 * CreateRepositoryPipelineVariable Method for CreateRepositoryPipelineVariable
	 * Create a repository level variable.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiCreateRepositoryPipelineVariableRequest
	 */
	CreateRepositoryPipelineVariable(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiCreateRepositoryPipelineVariableRequest

	/*
	 * CreateRepositoryPipelineVariableExecute executes the request
	 * @return PipelineVariable
	 */
	CreateRepositoryPipelineVariableExecute(r PipelinesApiApiCreateRepositoryPipelineVariableRequest) (PipelineVariable, *_nethttp.Response, error)

	/*
	 * DeleteDeploymentVariable Method for DeleteDeploymentVariable
	 * Delete a deployment environment level variable.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param environmentUuid The environment.
	 * @param variableUuid The UUID of the variable to delete.
	 * @return PipelinesApiApiDeleteDeploymentVariableRequest
	 */
	DeleteDeploymentVariable(ctx _context.Context, workspace string, repoSlug string, environmentUuid string, variableUuid string) PipelinesApiApiDeleteDeploymentVariableRequest

	/*
	 * DeleteDeploymentVariableExecute executes the request
	 */
	DeleteDeploymentVariableExecute(r PipelinesApiApiDeleteDeploymentVariableRequest) (*_nethttp.Response, error)

	/*
	 * DeletePipelineVariableForTeam Method for DeletePipelineVariableForTeam
	 * Delete a team level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param username The account.
	 * @param variableUuid The UUID of the variable to delete.
	 * @return PipelinesApiApiDeletePipelineVariableForTeamRequest
	 */
	DeletePipelineVariableForTeam(ctx _context.Context, username string, variableUuid string) PipelinesApiApiDeletePipelineVariableForTeamRequest

	/*
	 * DeletePipelineVariableForTeamExecute executes the request
	 */
	DeletePipelineVariableForTeamExecute(r PipelinesApiApiDeletePipelineVariableForTeamRequest) (*_nethttp.Response, error)

	/*
	 * DeletePipelineVariableForUser Method for DeletePipelineVariableForUser
	 * Delete an account level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
	 * @param variableUuid The UUID of the variable to delete.
	 * @return PipelinesApiApiDeletePipelineVariableForUserRequest
	 */
	DeletePipelineVariableForUser(ctx _context.Context, selectedUser string, variableUuid string) PipelinesApiApiDeletePipelineVariableForUserRequest

	/*
	 * DeletePipelineVariableForUserExecute executes the request
	 */
	DeletePipelineVariableForUserExecute(r PipelinesApiApiDeletePipelineVariableForUserRequest) (*_nethttp.Response, error)

	/*
	 * DeletePipelineVariableForWorkspace Method for DeletePipelineVariableForWorkspace
	 * Delete a workspace level variable.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param variableUuid The UUID of the variable to delete.
	 * @return PipelinesApiApiDeletePipelineVariableForWorkspaceRequest
	 */
	DeletePipelineVariableForWorkspace(ctx _context.Context, workspace string, variableUuid string) PipelinesApiApiDeletePipelineVariableForWorkspaceRequest

	/*
	 * DeletePipelineVariableForWorkspaceExecute executes the request
	 */
	DeletePipelineVariableForWorkspaceExecute(r PipelinesApiApiDeletePipelineVariableForWorkspaceRequest) (*_nethttp.Response, error)

	/*
	 * DeleteRepositoryPipelineCache Method for DeleteRepositoryPipelineCache
	 * Delete a repository cache.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace The account.
	 * @param repoSlug The repository.
	 * @param cacheUuid The UUID of the cache to delete.
	 * @return PipelinesApiApiDeleteRepositoryPipelineCacheRequest
	 */
	DeleteRepositoryPipelineCache(ctx _context.Context, workspace string, repoSlug string, cacheUuid string) PipelinesApiApiDeleteRepositoryPipelineCacheRequest

	/*
	 * DeleteRepositoryPipelineCacheExecute executes the request
	 */
	DeleteRepositoryPipelineCacheExecute(r PipelinesApiApiDeleteRepositoryPipelineCacheRequest) (*_nethttp.Response, error)

	/*
	 * DeleteRepositoryPipelineKeyPair Method for DeleteRepositoryPipelineKeyPair
	 * Delete the repository SSH key pair.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiDeleteRepositoryPipelineKeyPairRequest
	 */
	DeleteRepositoryPipelineKeyPair(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiDeleteRepositoryPipelineKeyPairRequest

	/*
	 * DeleteRepositoryPipelineKeyPairExecute executes the request
	 */
	DeleteRepositoryPipelineKeyPairExecute(r PipelinesApiApiDeleteRepositoryPipelineKeyPairRequest) (*_nethttp.Response, error)

	/*
	 * DeleteRepositoryPipelineKnownHost Method for DeleteRepositoryPipelineKnownHost
	 * Delete a repository level known host.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param knownHostUuid The UUID of the known host to delete.
	 * @return PipelinesApiApiDeleteRepositoryPipelineKnownHostRequest
	 */
	DeleteRepositoryPipelineKnownHost(ctx _context.Context, workspace string, repoSlug string, knownHostUuid string) PipelinesApiApiDeleteRepositoryPipelineKnownHostRequest

	/*
	 * DeleteRepositoryPipelineKnownHostExecute executes the request
	 */
	DeleteRepositoryPipelineKnownHostExecute(r PipelinesApiApiDeleteRepositoryPipelineKnownHostRequest) (*_nethttp.Response, error)

	/*
	 * DeleteRepositoryPipelineSchedule Method for DeleteRepositoryPipelineSchedule
	 * Delete a schedule.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param scheduleUuid The uuid of the schedule.
	 * @return PipelinesApiApiDeleteRepositoryPipelineScheduleRequest
	 */
	DeleteRepositoryPipelineSchedule(ctx _context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiApiDeleteRepositoryPipelineScheduleRequest

	/*
	 * DeleteRepositoryPipelineScheduleExecute executes the request
	 */
	DeleteRepositoryPipelineScheduleExecute(r PipelinesApiApiDeleteRepositoryPipelineScheduleRequest) (*_nethttp.Response, error)

	/*
	 * DeleteRepositoryPipelineVariable Method for DeleteRepositoryPipelineVariable
	 * Delete a repository level variable.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param variableUuid The UUID of the variable to delete.
	 * @return PipelinesApiApiDeleteRepositoryPipelineVariableRequest
	 */
	DeleteRepositoryPipelineVariable(ctx _context.Context, workspace string, repoSlug string, variableUuid string) PipelinesApiApiDeleteRepositoryPipelineVariableRequest

	/*
	 * DeleteRepositoryPipelineVariableExecute executes the request
	 */
	DeleteRepositoryPipelineVariableExecute(r PipelinesApiApiDeleteRepositoryPipelineVariableRequest) (*_nethttp.Response, error)

	/*
	 * GetDeploymentVariables Method for GetDeploymentVariables
	 * Find deployment environment level variables.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param environmentUuid The environment.
	 * @return PipelinesApiApiGetDeploymentVariablesRequest
	 */
	GetDeploymentVariables(ctx _context.Context, workspace string, repoSlug string, environmentUuid string) PipelinesApiApiGetDeploymentVariablesRequest

	/*
	 * GetDeploymentVariablesExecute executes the request
	 * @return PaginatedDeploymentVariable
	 */
	GetDeploymentVariablesExecute(r PipelinesApiApiGetDeploymentVariablesRequest) (PaginatedDeploymentVariable, *_nethttp.Response, error)

	/*
	 * GetPipelineForRepository Method for GetPipelineForRepository
	 * Retrieve a specified pipeline
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param pipelineUuid The pipeline UUID.
	 * @return PipelinesApiApiGetPipelineForRepositoryRequest
	 */
	GetPipelineForRepository(ctx _context.Context, workspace string, repoSlug string, pipelineUuid string) PipelinesApiApiGetPipelineForRepositoryRequest

	/*
	 * GetPipelineForRepositoryExecute executes the request
	 * @return Pipeline
	 */
	GetPipelineForRepositoryExecute(r PipelinesApiApiGetPipelineForRepositoryRequest) (Pipeline, *_nethttp.Response, error)

	/*
	 * GetPipelineStepForRepository Method for GetPipelineStepForRepository
	 * Retrieve a given step of a pipeline.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param pipelineUuid The UUID of the pipeline.
	 * @param stepUuid The UUID of the step.
	 * @return PipelinesApiApiGetPipelineStepForRepositoryRequest
	 */
	GetPipelineStepForRepository(ctx _context.Context, workspace string, repoSlug string, pipelineUuid string, stepUuid string) PipelinesApiApiGetPipelineStepForRepositoryRequest

	/*
	 * GetPipelineStepForRepositoryExecute executes the request
	 * @return PipelineStep
	 */
	GetPipelineStepForRepositoryExecute(r PipelinesApiApiGetPipelineStepForRepositoryRequest) (PipelineStep, *_nethttp.Response, error)

	/*
	 * GetPipelineStepLogForRepository Method for GetPipelineStepLogForRepository
	 * Retrieve the log file for a given step of a pipeline.

This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param pipelineUuid The UUID of the pipeline.
	 * @param stepUuid The UUID of the step.
	 * @return PipelinesApiApiGetPipelineStepLogForRepositoryRequest
	 */
	GetPipelineStepLogForRepository(ctx _context.Context, workspace string, repoSlug string, pipelineUuid string, stepUuid string) PipelinesApiApiGetPipelineStepLogForRepositoryRequest

	/*
	 * GetPipelineStepLogForRepositoryExecute executes the request
	 */
	GetPipelineStepLogForRepositoryExecute(r PipelinesApiApiGetPipelineStepLogForRepositoryRequest) (*_nethttp.Response, error)

	/*
	 * GetPipelineStepsForRepository Method for GetPipelineStepsForRepository
	 * Find steps for the given pipeline.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param pipelineUuid The UUID of the pipeline.
	 * @return PipelinesApiApiGetPipelineStepsForRepositoryRequest
	 */
	GetPipelineStepsForRepository(ctx _context.Context, workspace string, repoSlug string, pipelineUuid string) PipelinesApiApiGetPipelineStepsForRepositoryRequest

	/*
	 * GetPipelineStepsForRepositoryExecute executes the request
	 * @return PaginatedPipelineSteps
	 */
	GetPipelineStepsForRepositoryExecute(r PipelinesApiApiGetPipelineStepsForRepositoryRequest) (PaginatedPipelineSteps, *_nethttp.Response, error)

	/*
	 * GetPipelineVariableForTeam Method for GetPipelineVariableForTeam
	 * Retrieve a team level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param username The account.
	 * @param variableUuid The UUID of the variable to retrieve.
	 * @return PipelinesApiApiGetPipelineVariableForTeamRequest
	 */
	GetPipelineVariableForTeam(ctx _context.Context, username string, variableUuid string) PipelinesApiApiGetPipelineVariableForTeamRequest

	/*
	 * GetPipelineVariableForTeamExecute executes the request
	 * @return PipelineVariable
	 */
	GetPipelineVariableForTeamExecute(r PipelinesApiApiGetPipelineVariableForTeamRequest) (PipelineVariable, *_nethttp.Response, error)

	/*
	 * GetPipelineVariableForUser Method for GetPipelineVariableForUser
	 * Retrieve a user level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
	 * @param variableUuid The UUID of the variable to retrieve.
	 * @return PipelinesApiApiGetPipelineVariableForUserRequest
	 */
	GetPipelineVariableForUser(ctx _context.Context, selectedUser string, variableUuid string) PipelinesApiApiGetPipelineVariableForUserRequest

	/*
	 * GetPipelineVariableForUserExecute executes the request
	 * @return PipelineVariable
	 */
	GetPipelineVariableForUserExecute(r PipelinesApiApiGetPipelineVariableForUserRequest) (PipelineVariable, *_nethttp.Response, error)

	/*
	 * GetPipelineVariableForWorkspace Method for GetPipelineVariableForWorkspace
	 * Retrieve a workspace level variable.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param variableUuid The UUID of the variable to retrieve.
	 * @return PipelinesApiApiGetPipelineVariableForWorkspaceRequest
	 */
	GetPipelineVariableForWorkspace(ctx _context.Context, workspace string, variableUuid string) PipelinesApiApiGetPipelineVariableForWorkspaceRequest

	/*
	 * GetPipelineVariableForWorkspaceExecute executes the request
	 * @return PipelineVariable
	 */
	GetPipelineVariableForWorkspaceExecute(r PipelinesApiApiGetPipelineVariableForWorkspaceRequest) (PipelineVariable, *_nethttp.Response, error)

	/*
	 * GetPipelineVariablesForTeam Method for GetPipelineVariablesForTeam
	 * Find account level variables.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param username This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @return PipelinesApiApiGetPipelineVariablesForTeamRequest
	 */
	GetPipelineVariablesForTeam(ctx _context.Context, username string) PipelinesApiApiGetPipelineVariablesForTeamRequest

	/*
	 * GetPipelineVariablesForTeamExecute executes the request
	 * @return PaginatedPipelineVariables
	 */
	GetPipelineVariablesForTeamExecute(r PipelinesApiApiGetPipelineVariablesForTeamRequest) (PaginatedPipelineVariables, *_nethttp.Response, error)

	/*
	 * GetPipelineVariablesForUser Method for GetPipelineVariablesForUser
	 * Find user level variables.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
	 * @return PipelinesApiApiGetPipelineVariablesForUserRequest
	 */
	GetPipelineVariablesForUser(ctx _context.Context, selectedUser string) PipelinesApiApiGetPipelineVariablesForUserRequest

	/*
	 * GetPipelineVariablesForUserExecute executes the request
	 * @return PaginatedPipelineVariables
	 */
	GetPipelineVariablesForUserExecute(r PipelinesApiApiGetPipelineVariablesForUserRequest) (PaginatedPipelineVariables, *_nethttp.Response, error)

	/*
	 * GetPipelineVariablesForWorkspace Method for GetPipelineVariablesForWorkspace
	 * Find workspace level variables.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @return PipelinesApiApiGetPipelineVariablesForWorkspaceRequest
	 */
	GetPipelineVariablesForWorkspace(ctx _context.Context, workspace string) PipelinesApiApiGetPipelineVariablesForWorkspaceRequest

	/*
	 * GetPipelineVariablesForWorkspaceExecute executes the request
	 * @return PaginatedPipelineVariables
	 */
	GetPipelineVariablesForWorkspaceExecute(r PipelinesApiApiGetPipelineVariablesForWorkspaceRequest) (PaginatedPipelineVariables, *_nethttp.Response, error)

	/*
	 * GetPipelinesForRepository Method for GetPipelinesForRepository
	 * Find pipelines
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiGetPipelinesForRepositoryRequest
	 */
	GetPipelinesForRepository(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetPipelinesForRepositoryRequest

	/*
	 * GetPipelinesForRepositoryExecute executes the request
	 * @return PaginatedPipelines
	 */
	GetPipelinesForRepositoryExecute(r PipelinesApiApiGetPipelinesForRepositoryRequest) (PaginatedPipelines, *_nethttp.Response, error)

	/*
	 * GetRepositoryPipelineCacheContentURI Method for GetRepositoryPipelineCacheContentURI
	 * Retrieve the URI of the content of the specified cache.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace The account.
	 * @param repoSlug The repository.
	 * @param cacheUuid The UUID of the cache.
	 * @return PipelinesApiApiGetRepositoryPipelineCacheContentURIRequest
	 */
	GetRepositoryPipelineCacheContentURI(ctx _context.Context, workspace string, repoSlug string, cacheUuid string) PipelinesApiApiGetRepositoryPipelineCacheContentURIRequest

	/*
	 * GetRepositoryPipelineCacheContentURIExecute executes the request
	 * @return PipelineCacheContentUri
	 */
	GetRepositoryPipelineCacheContentURIExecute(r PipelinesApiApiGetRepositoryPipelineCacheContentURIRequest) (PipelineCacheContentUri, *_nethttp.Response, error)

	/*
	 * GetRepositoryPipelineCaches Method for GetRepositoryPipelineCaches
	 * Retrieve the repository pipelines caches.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace The account.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiGetRepositoryPipelineCachesRequest
	 */
	GetRepositoryPipelineCaches(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineCachesRequest

	/*
	 * GetRepositoryPipelineCachesExecute executes the request
	 * @return PaginatedPipelineCaches
	 */
	GetRepositoryPipelineCachesExecute(r PipelinesApiApiGetRepositoryPipelineCachesRequest) (PaginatedPipelineCaches, *_nethttp.Response, error)

	/*
	 * GetRepositoryPipelineConfig Method for GetRepositoryPipelineConfig
	 * Retrieve the repository pipelines configuration.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace The account.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiGetRepositoryPipelineConfigRequest
	 */
	GetRepositoryPipelineConfig(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineConfigRequest

	/*
	 * GetRepositoryPipelineConfigExecute executes the request
	 * @return PipelinesConfig
	 */
	GetRepositoryPipelineConfigExecute(r PipelinesApiApiGetRepositoryPipelineConfigRequest) (PipelinesConfig, *_nethttp.Response, error)

	/*
	 * GetRepositoryPipelineKnownHost Method for GetRepositoryPipelineKnownHost
	 * Retrieve a repository level known host.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param knownHostUuid The UUID of the known host to retrieve.
	 * @return PipelinesApiApiGetRepositoryPipelineKnownHostRequest
	 */
	GetRepositoryPipelineKnownHost(ctx _context.Context, workspace string, repoSlug string, knownHostUuid string) PipelinesApiApiGetRepositoryPipelineKnownHostRequest

	/*
	 * GetRepositoryPipelineKnownHostExecute executes the request
	 * @return PipelineKnownHost
	 */
	GetRepositoryPipelineKnownHostExecute(r PipelinesApiApiGetRepositoryPipelineKnownHostRequest) (PipelineKnownHost, *_nethttp.Response, error)

	/*
	 * GetRepositoryPipelineKnownHosts Method for GetRepositoryPipelineKnownHosts
	 * Find repository level known hosts.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiGetRepositoryPipelineKnownHostsRequest
	 */
	GetRepositoryPipelineKnownHosts(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineKnownHostsRequest

	/*
	 * GetRepositoryPipelineKnownHostsExecute executes the request
	 * @return PaginatedPipelineKnownHosts
	 */
	GetRepositoryPipelineKnownHostsExecute(r PipelinesApiApiGetRepositoryPipelineKnownHostsRequest) (PaginatedPipelineKnownHosts, *_nethttp.Response, error)

	/*
	 * GetRepositoryPipelineSchedule Method for GetRepositoryPipelineSchedule
	 * Retrieve a schedule by its UUID.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param scheduleUuid The uuid of the schedule.
	 * @return PipelinesApiApiGetRepositoryPipelineScheduleRequest
	 */
	GetRepositoryPipelineSchedule(ctx _context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiApiGetRepositoryPipelineScheduleRequest

	/*
	 * GetRepositoryPipelineScheduleExecute executes the request
	 * @return PipelineSchedule
	 */
	GetRepositoryPipelineScheduleExecute(r PipelinesApiApiGetRepositoryPipelineScheduleRequest) (PipelineSchedule, *_nethttp.Response, error)

	/*
	 * GetRepositoryPipelineScheduleExecutions Method for GetRepositoryPipelineScheduleExecutions
	 * Retrieve the executions of a given schedule.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param scheduleUuid schedule_uuid
	 * @return PipelinesApiApiGetRepositoryPipelineScheduleExecutionsRequest
	 */
	GetRepositoryPipelineScheduleExecutions(ctx _context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiApiGetRepositoryPipelineScheduleExecutionsRequest

	/*
	 * GetRepositoryPipelineScheduleExecutionsExecute executes the request
	 * @return PaginatedPipelineScheduleExecutions
	 */
	GetRepositoryPipelineScheduleExecutionsExecute(r PipelinesApiApiGetRepositoryPipelineScheduleExecutionsRequest) (PaginatedPipelineScheduleExecutions, *_nethttp.Response, error)

	/*
	 * GetRepositoryPipelineSchedules Method for GetRepositoryPipelineSchedules
	 * Retrieve the configured schedules for the given repository.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiGetRepositoryPipelineSchedulesRequest
	 */
	GetRepositoryPipelineSchedules(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineSchedulesRequest

	/*
	 * GetRepositoryPipelineSchedulesExecute executes the request
	 * @return PaginatedPipelineSchedules
	 */
	GetRepositoryPipelineSchedulesExecute(r PipelinesApiApiGetRepositoryPipelineSchedulesRequest) (PaginatedPipelineSchedules, *_nethttp.Response, error)

	/*
	 * GetRepositoryPipelineSshKeyPair Method for GetRepositoryPipelineSshKeyPair
	 * Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiGetRepositoryPipelineSshKeyPairRequest
	 */
	GetRepositoryPipelineSshKeyPair(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineSshKeyPairRequest

	/*
	 * GetRepositoryPipelineSshKeyPairExecute executes the request
	 * @return PipelineSshKeyPair
	 */
	GetRepositoryPipelineSshKeyPairExecute(r PipelinesApiApiGetRepositoryPipelineSshKeyPairRequest) (PipelineSshKeyPair, *_nethttp.Response, error)

	/*
	 * GetRepositoryPipelineVariable Method for GetRepositoryPipelineVariable
	 * Retrieve a repository level variable.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param variableUuid The UUID of the variable to retrieve.
	 * @return PipelinesApiApiGetRepositoryPipelineVariableRequest
	 */
	GetRepositoryPipelineVariable(ctx _context.Context, workspace string, repoSlug string, variableUuid string) PipelinesApiApiGetRepositoryPipelineVariableRequest

	/*
	 * GetRepositoryPipelineVariableExecute executes the request
	 * @return PipelineVariable
	 */
	GetRepositoryPipelineVariableExecute(r PipelinesApiApiGetRepositoryPipelineVariableRequest) (PipelineVariable, *_nethttp.Response, error)

	/*
	 * GetRepositoryPipelineVariables Method for GetRepositoryPipelineVariables
	 * Find repository level variables.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiGetRepositoryPipelineVariablesRequest
	 */
	GetRepositoryPipelineVariables(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineVariablesRequest

	/*
	 * GetRepositoryPipelineVariablesExecute executes the request
	 * @return PaginatedPipelineVariables
	 */
	GetRepositoryPipelineVariablesExecute(r PipelinesApiApiGetRepositoryPipelineVariablesRequest) (PaginatedPipelineVariables, *_nethttp.Response, error)

	/*
	 * StopPipeline Method for StopPipeline
	 * Signal the stop of a pipeline and all of its steps that not have completed yet.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param pipelineUuid The UUID of the pipeline.
	 * @return PipelinesApiApiStopPipelineRequest
	 */
	StopPipeline(ctx _context.Context, workspace string, repoSlug string, pipelineUuid string) PipelinesApiApiStopPipelineRequest

	/*
	 * StopPipelineExecute executes the request
	 */
	StopPipelineExecute(r PipelinesApiApiStopPipelineRequest) (*_nethttp.Response, error)

	/*
	 * UpdateDeploymentVariable Method for UpdateDeploymentVariable
	 * Update a deployment environment level variable.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param environmentUuid The environment.
	 * @param variableUuid The UUID of the variable to update.
	 * @return PipelinesApiApiUpdateDeploymentVariableRequest
	 */
	UpdateDeploymentVariable(ctx _context.Context, workspace string, repoSlug string, environmentUuid string, variableUuid string) PipelinesApiApiUpdateDeploymentVariableRequest

	/*
	 * UpdateDeploymentVariableExecute executes the request
	 * @return DeploymentVariable
	 */
	UpdateDeploymentVariableExecute(r PipelinesApiApiUpdateDeploymentVariableRequest) (DeploymentVariable, *_nethttp.Response, error)

	/*
	 * UpdatePipelineVariableForTeam Method for UpdatePipelineVariableForTeam
	 * Update a team level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param username The account.
	 * @param variableUuid The UUID of the variable.
	 * @return PipelinesApiApiUpdatePipelineVariableForTeamRequest
	 */
	UpdatePipelineVariableForTeam(ctx _context.Context, username string, variableUuid string) PipelinesApiApiUpdatePipelineVariableForTeamRequest

	/*
	 * UpdatePipelineVariableForTeamExecute executes the request
	 * @return PipelineVariable
	 */
	UpdatePipelineVariableForTeamExecute(r PipelinesApiApiUpdatePipelineVariableForTeamRequest) (PipelineVariable, *_nethttp.Response, error)

	/*
	 * UpdatePipelineVariableForUser Method for UpdatePipelineVariableForUser
	 * Update a user level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
	 * @param variableUuid The UUID of the variable.
	 * @return PipelinesApiApiUpdatePipelineVariableForUserRequest
	 */
	UpdatePipelineVariableForUser(ctx _context.Context, selectedUser string, variableUuid string) PipelinesApiApiUpdatePipelineVariableForUserRequest

	/*
	 * UpdatePipelineVariableForUserExecute executes the request
	 * @return PipelineVariable
	 */
	UpdatePipelineVariableForUserExecute(r PipelinesApiApiUpdatePipelineVariableForUserRequest) (PipelineVariable, *_nethttp.Response, error)

	/*
	 * UpdatePipelineVariableForWorkspace Method for UpdatePipelineVariableForWorkspace
	 * Update a workspace level variable.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param variableUuid The UUID of the variable.
	 * @return PipelinesApiApiUpdatePipelineVariableForWorkspaceRequest
	 */
	UpdatePipelineVariableForWorkspace(ctx _context.Context, workspace string, variableUuid string) PipelinesApiApiUpdatePipelineVariableForWorkspaceRequest

	/*
	 * UpdatePipelineVariableForWorkspaceExecute executes the request
	 * @return PipelineVariable
	 */
	UpdatePipelineVariableForWorkspaceExecute(r PipelinesApiApiUpdatePipelineVariableForWorkspaceRequest) (PipelineVariable, *_nethttp.Response, error)

	/*
	 * UpdateRepositoryBuildNumber Method for UpdateRepositoryBuildNumber
	 * Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiUpdateRepositoryBuildNumberRequest
	 */
	UpdateRepositoryBuildNumber(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiUpdateRepositoryBuildNumberRequest

	/*
	 * UpdateRepositoryBuildNumberExecute executes the request
	 * @return PipelineBuildNumber
	 */
	UpdateRepositoryBuildNumberExecute(r PipelinesApiApiUpdateRepositoryBuildNumberRequest) (PipelineBuildNumber, *_nethttp.Response, error)

	/*
	 * UpdateRepositoryPipelineConfig Method for UpdateRepositoryPipelineConfig
	 * Update the pipelines configuration for a repository.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiUpdateRepositoryPipelineConfigRequest
	 */
	UpdateRepositoryPipelineConfig(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiUpdateRepositoryPipelineConfigRequest

	/*
	 * UpdateRepositoryPipelineConfigExecute executes the request
	 * @return PipelinesConfig
	 */
	UpdateRepositoryPipelineConfigExecute(r PipelinesApiApiUpdateRepositoryPipelineConfigRequest) (PipelinesConfig, *_nethttp.Response, error)

	/*
	 * UpdateRepositoryPipelineKeyPair Method for UpdateRepositoryPipelineKeyPair
	 * Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @return PipelinesApiApiUpdateRepositoryPipelineKeyPairRequest
	 */
	UpdateRepositoryPipelineKeyPair(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiUpdateRepositoryPipelineKeyPairRequest

	/*
	 * UpdateRepositoryPipelineKeyPairExecute executes the request
	 * @return PipelineSshKeyPair
	 */
	UpdateRepositoryPipelineKeyPairExecute(r PipelinesApiApiUpdateRepositoryPipelineKeyPairRequest) (PipelineSshKeyPair, *_nethttp.Response, error)

	/*
	 * UpdateRepositoryPipelineKnownHost Method for UpdateRepositoryPipelineKnownHost
	 * Update a repository level known host.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param knownHostUuid The UUID of the known host to update.
	 * @return PipelinesApiApiUpdateRepositoryPipelineKnownHostRequest
	 */
	UpdateRepositoryPipelineKnownHost(ctx _context.Context, workspace string, repoSlug string, knownHostUuid string) PipelinesApiApiUpdateRepositoryPipelineKnownHostRequest

	/*
	 * UpdateRepositoryPipelineKnownHostExecute executes the request
	 * @return PipelineKnownHost
	 */
	UpdateRepositoryPipelineKnownHostExecute(r PipelinesApiApiUpdateRepositoryPipelineKnownHostRequest) (PipelineKnownHost, *_nethttp.Response, error)

	/*
	 * UpdateRepositoryPipelineSchedule Method for UpdateRepositoryPipelineSchedule
	 * Update a schedule.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param scheduleUuid The uuid of the schedule.
	 * @return PipelinesApiApiUpdateRepositoryPipelineScheduleRequest
	 */
	UpdateRepositoryPipelineSchedule(ctx _context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiApiUpdateRepositoryPipelineScheduleRequest

	/*
	 * UpdateRepositoryPipelineScheduleExecute executes the request
	 * @return PipelineSchedule
	 */
	UpdateRepositoryPipelineScheduleExecute(r PipelinesApiApiUpdateRepositoryPipelineScheduleRequest) (PipelineSchedule, *_nethttp.Response, error)

	/*
	 * UpdateRepositoryPipelineVariable Method for UpdateRepositoryPipelineVariable
	 * Update a repository level variable.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
	 * @param repoSlug The repository.
	 * @param variableUuid The UUID of the variable to update.
	 * @return PipelinesApiApiUpdateRepositoryPipelineVariableRequest
	 */
	UpdateRepositoryPipelineVariable(ctx _context.Context, workspace string, repoSlug string, variableUuid string) PipelinesApiApiUpdateRepositoryPipelineVariableRequest

	/*
	 * UpdateRepositoryPipelineVariableExecute executes the request
	 * @return PipelineVariable
	 */
	UpdateRepositoryPipelineVariableExecute(r PipelinesApiApiUpdateRepositoryPipelineVariableRequest) (PipelineVariable, *_nethttp.Response, error)
}

// PipelinesApiService PipelinesApi service
type PipelinesApiService service

type PipelinesApiApiCreateDeploymentVariableRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	environmentUuid string
	variableUuid string
	body *DeploymentVariable
}

func (r PipelinesApiApiCreateDeploymentVariableRequest) Body(body DeploymentVariable) PipelinesApiApiCreateDeploymentVariableRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiCreateDeploymentVariableRequest) Execute() (DeploymentVariable, *_nethttp.Response, error) {
	return r.ApiService.CreateDeploymentVariableExecute(r)
}

/*
 * CreateDeploymentVariable Method for CreateDeploymentVariable
 * Create a deployment environment level variable.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param environmentUuid The environment.
 * @param variableUuid The UUID of the variable to update.
 * @return PipelinesApiApiCreateDeploymentVariableRequest
 */
func (a *PipelinesApiService) CreateDeploymentVariable(ctx _context.Context, workspace string, repoSlug string, environmentUuid string, variableUuid string) PipelinesApiApiCreateDeploymentVariableRequest {
	return PipelinesApiApiCreateDeploymentVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		environmentUuid: environmentUuid,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 * @return DeploymentVariable
 */
func (a *PipelinesApiService) CreateDeploymentVariableExecute(r PipelinesApiApiCreateDeploymentVariableRequest) (DeploymentVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeploymentVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreateDeploymentVariable")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_uuid"+"}", _neturl.PathEscape(parameterToString(r.environmentUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiCreatePipelineForRepositoryRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	body *Pipeline
}

func (r PipelinesApiApiCreatePipelineForRepositoryRequest) Body(body Pipeline) PipelinesApiApiCreatePipelineForRepositoryRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiCreatePipelineForRepositoryRequest) Execute() (Pipeline, *_nethttp.Response, error) {
	return r.ApiService.CreatePipelineForRepositoryExecute(r)
}

/*
 * CreatePipelineForRepository Method for CreatePipelineForRepository
 * Endpoint to create and initiate a pipeline.
There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated.
# Trigger a Pipeline for a branch
One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline.
The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
  -d '
  {
    "target": {
      "ref_type": "branch",
      "type": "pipeline_ref_target",
      "ref_name": "master"
    }
  }'
```
# Trigger a Pipeline for a commit on a branch or tag
You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark).
The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.

The following reference types are supported:

* `branch`
* `named_branch`
* `bookmark`
 * `tag`

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
  -d '
  {
    "target": {
      "commit": {
        "type": "commit",
        "hash": "ce5b7431602f7cbba007062eeb55225c6e18e956"
      },
      "ref_type": "branch",
      "type": "pipeline_ref_target",
      "ref_name": "master"
    }
  }'
```
# Trigger a specific pipeline definition for a commit
You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit.
In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
 -d '
  {
     "target": {
      "commit": {
         "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
         "type":"commit"
       },
        "selector": {
           "type":"custom",
              "pattern":"Deploy to production"
          },
        "type":"pipeline_commit_target"
   }
  }'
```
# Trigger a specific pipeline definition for a commit on a branch or tag
You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference.
In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
 -d '
  {
     "target": {
      "commit": {
         "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
         "type":"commit"
       },
       "selector": {
          "type": "custom",
          "pattern": "Deploy to production"
       },
       "type": "pipeline_ref_target",
       "ref_name": "master",
       "ref_type": "branch"
     }
  }'
```


# Trigger a custom pipeline with variables
In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
 -d '
  {
    "target": {
      "type": "pipeline_ref_target",
      "ref_type": "branch",
      "ref_name": "master",
      "selector": {
        "type": "custom",
        "pattern": "Deploy to production"
      }
    },
    "variables": [
      {
        "key": "var1key",
        "value": "var1value",
        "secured": true
      },
      {
        "key": "var2key",
        "value": "var2value"
      }
    ]
  }'
```

# Trigger a pull request pipeline

You can also initiate a pipeline for a specific pull request.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
 -d '
  {
	"target": {
      "type": "pipeline_pullrequest_target",
	  "source": "pull-request-branch",
      "destination": "master",
      "destination_commit": {
      	 "hash" : "9f848b7"
      },
      "commit": {
      	"hash" : "1a372fc"
      },
      "pullrequest" : {
      	"id" : "3"
      },
	  "selector": {
        "type": "pull-requests",
        "pattern": "**"
      }
    }
  }'
```

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiCreatePipelineForRepositoryRequest
 */
func (a *PipelinesApiService) CreatePipelineForRepository(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiCreatePipelineForRepositoryRequest {
	return PipelinesApiApiCreatePipelineForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return Pipeline
 */
func (a *PipelinesApiService) CreatePipelineForRepositoryExecute(r PipelinesApiApiCreatePipelineForRepositoryRequest) (Pipeline, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Pipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreatePipelineForRepository")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiCreatePipelineVariableForTeamRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	username string
	body *PipelineVariable
}

func (r PipelinesApiApiCreatePipelineVariableForTeamRequest) Body(body PipelineVariable) PipelinesApiApiCreatePipelineVariableForTeamRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiCreatePipelineVariableForTeamRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.CreatePipelineVariableForTeamExecute(r)
}

/*
 * CreatePipelineVariableForTeam Method for CreatePipelineVariableForTeam
 * Create an account level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param username This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @return PipelinesApiApiCreatePipelineVariableForTeamRequest
 */
func (a *PipelinesApiService) CreatePipelineVariableForTeam(ctx _context.Context, username string) PipelinesApiApiCreatePipelineVariableForTeamRequest {
	return PipelinesApiApiCreatePipelineVariableForTeamRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) CreatePipelineVariableForTeamExecute(r PipelinesApiApiCreatePipelineVariableForTeamRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreatePipelineVariableForTeam")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{username}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", _neturl.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiCreatePipelineVariableForUserRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	selectedUser string
	body *PipelineVariable
}

func (r PipelinesApiApiCreatePipelineVariableForUserRequest) Body(body PipelineVariable) PipelinesApiApiCreatePipelineVariableForUserRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiCreatePipelineVariableForUserRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.CreatePipelineVariableForUserExecute(r)
}

/*
 * CreatePipelineVariableForUser Method for CreatePipelineVariableForUser
 * Create a user level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
 * @return PipelinesApiApiCreatePipelineVariableForUserRequest
 */
func (a *PipelinesApiService) CreatePipelineVariableForUser(ctx _context.Context, selectedUser string) PipelinesApiApiCreatePipelineVariableForUserRequest {
	return PipelinesApiApiCreatePipelineVariableForUserRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) CreatePipelineVariableForUserExecute(r PipelinesApiApiCreatePipelineVariableForUserRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreatePipelineVariableForUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{selected_user}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", _neturl.PathEscape(parameterToString(r.selectedUser, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiCreatePipelineVariableForWorkspaceRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	body *PipelineVariable
}

func (r PipelinesApiApiCreatePipelineVariableForWorkspaceRequest) Body(body PipelineVariable) PipelinesApiApiCreatePipelineVariableForWorkspaceRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiCreatePipelineVariableForWorkspaceRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.CreatePipelineVariableForWorkspaceExecute(r)
}

/*
 * CreatePipelineVariableForWorkspace Method for CreatePipelineVariableForWorkspace
 * Create a workspace level variable.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @return PipelinesApiApiCreatePipelineVariableForWorkspaceRequest
 */
func (a *PipelinesApiService) CreatePipelineVariableForWorkspace(ctx _context.Context, workspace string) PipelinesApiApiCreatePipelineVariableForWorkspaceRequest {
	return PipelinesApiApiCreatePipelineVariableForWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) CreatePipelineVariableForWorkspaceExecute(r PipelinesApiApiCreatePipelineVariableForWorkspaceRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreatePipelineVariableForWorkspace")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiCreateRepositoryPipelineKnownHostRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	body *PipelineKnownHost
}

func (r PipelinesApiApiCreateRepositoryPipelineKnownHostRequest) Body(body PipelineKnownHost) PipelinesApiApiCreateRepositoryPipelineKnownHostRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiCreateRepositoryPipelineKnownHostRequest) Execute() (PipelineKnownHost, *_nethttp.Response, error) {
	return r.ApiService.CreateRepositoryPipelineKnownHostExecute(r)
}

/*
 * CreateRepositoryPipelineKnownHost Method for CreateRepositoryPipelineKnownHost
 * Create a repository level known host.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiCreateRepositoryPipelineKnownHostRequest
 */
func (a *PipelinesApiService) CreateRepositoryPipelineKnownHost(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiCreateRepositoryPipelineKnownHostRequest {
	return PipelinesApiApiCreateRepositoryPipelineKnownHostRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PipelineKnownHost
 */
func (a *PipelinesApiService) CreateRepositoryPipelineKnownHostExecute(r PipelinesApiApiCreateRepositoryPipelineKnownHostRequest) (PipelineKnownHost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineKnownHost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreateRepositoryPipelineKnownHost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiCreateRepositoryPipelineScheduleRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	body *PipelineSchedule
}

func (r PipelinesApiApiCreateRepositoryPipelineScheduleRequest) Body(body PipelineSchedule) PipelinesApiApiCreateRepositoryPipelineScheduleRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiCreateRepositoryPipelineScheduleRequest) Execute() (PipelineSchedule, *_nethttp.Response, error) {
	return r.ApiService.CreateRepositoryPipelineScheduleExecute(r)
}

/*
 * CreateRepositoryPipelineSchedule Method for CreateRepositoryPipelineSchedule
 * Create a schedule for the given repository.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiCreateRepositoryPipelineScheduleRequest
 */
func (a *PipelinesApiService) CreateRepositoryPipelineSchedule(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiCreateRepositoryPipelineScheduleRequest {
	return PipelinesApiApiCreateRepositoryPipelineScheduleRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PipelineSchedule
 */
func (a *PipelinesApiService) CreateRepositoryPipelineScheduleExecute(r PipelinesApiApiCreateRepositoryPipelineScheduleRequest) (PipelineSchedule, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineSchedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreateRepositoryPipelineSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiCreateRepositoryPipelineVariableRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	body *PipelineVariable
}

func (r PipelinesApiApiCreateRepositoryPipelineVariableRequest) Body(body PipelineVariable) PipelinesApiApiCreateRepositoryPipelineVariableRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiCreateRepositoryPipelineVariableRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.CreateRepositoryPipelineVariableExecute(r)
}

/*
 * CreateRepositoryPipelineVariable Method for CreateRepositoryPipelineVariable
 * Create a repository level variable.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiCreateRepositoryPipelineVariableRequest
 */
func (a *PipelinesApiService) CreateRepositoryPipelineVariable(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiCreateRepositoryPipelineVariableRequest {
	return PipelinesApiApiCreateRepositoryPipelineVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) CreateRepositoryPipelineVariableExecute(r PipelinesApiApiCreateRepositoryPipelineVariableRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreateRepositoryPipelineVariable")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiDeleteDeploymentVariableRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	environmentUuid string
	variableUuid string
}


func (r PipelinesApiApiDeleteDeploymentVariableRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDeploymentVariableExecute(r)
}

/*
 * DeleteDeploymentVariable Method for DeleteDeploymentVariable
 * Delete a deployment environment level variable.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param environmentUuid The environment.
 * @param variableUuid The UUID of the variable to delete.
 * @return PipelinesApiApiDeleteDeploymentVariableRequest
 */
func (a *PipelinesApiService) DeleteDeploymentVariable(ctx _context.Context, workspace string, repoSlug string, environmentUuid string, variableUuid string) PipelinesApiApiDeleteDeploymentVariableRequest {
	return PipelinesApiApiDeleteDeploymentVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		environmentUuid: environmentUuid,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PipelinesApiService) DeleteDeploymentVariableExecute(r PipelinesApiApiDeleteDeploymentVariableRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteDeploymentVariable")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_uuid"+"}", _neturl.PathEscape(parameterToString(r.environmentUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiApiDeletePipelineVariableForTeamRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	username string
	variableUuid string
}


func (r PipelinesApiApiDeletePipelineVariableForTeamRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeletePipelineVariableForTeamExecute(r)
}

/*
 * DeletePipelineVariableForTeam Method for DeletePipelineVariableForTeam
 * Delete a team level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param username The account.
 * @param variableUuid The UUID of the variable to delete.
 * @return PipelinesApiApiDeletePipelineVariableForTeamRequest
 */
func (a *PipelinesApiService) DeletePipelineVariableForTeam(ctx _context.Context, username string, variableUuid string) PipelinesApiApiDeletePipelineVariableForTeamRequest {
	return PipelinesApiApiDeletePipelineVariableForTeamRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PipelinesApiService) DeletePipelineVariableForTeamExecute(r PipelinesApiApiDeletePipelineVariableForTeamRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeletePipelineVariableForTeam")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{username}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", _neturl.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiApiDeletePipelineVariableForUserRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	selectedUser string
	variableUuid string
}


func (r PipelinesApiApiDeletePipelineVariableForUserRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeletePipelineVariableForUserExecute(r)
}

/*
 * DeletePipelineVariableForUser Method for DeletePipelineVariableForUser
 * Delete an account level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
 * @param variableUuid The UUID of the variable to delete.
 * @return PipelinesApiApiDeletePipelineVariableForUserRequest
 */
func (a *PipelinesApiService) DeletePipelineVariableForUser(ctx _context.Context, selectedUser string, variableUuid string) PipelinesApiApiDeletePipelineVariableForUserRequest {
	return PipelinesApiApiDeletePipelineVariableForUserRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PipelinesApiService) DeletePipelineVariableForUserExecute(r PipelinesApiApiDeletePipelineVariableForUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeletePipelineVariableForUser")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{selected_user}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", _neturl.PathEscape(parameterToString(r.selectedUser, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiApiDeletePipelineVariableForWorkspaceRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	variableUuid string
}


func (r PipelinesApiApiDeletePipelineVariableForWorkspaceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeletePipelineVariableForWorkspaceExecute(r)
}

/*
 * DeletePipelineVariableForWorkspace Method for DeletePipelineVariableForWorkspace
 * Delete a workspace level variable.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param variableUuid The UUID of the variable to delete.
 * @return PipelinesApiApiDeletePipelineVariableForWorkspaceRequest
 */
func (a *PipelinesApiService) DeletePipelineVariableForWorkspace(ctx _context.Context, workspace string, variableUuid string) PipelinesApiApiDeletePipelineVariableForWorkspaceRequest {
	return PipelinesApiApiDeletePipelineVariableForWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PipelinesApiService) DeletePipelineVariableForWorkspaceExecute(r PipelinesApiApiDeletePipelineVariableForWorkspaceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeletePipelineVariableForWorkspace")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiApiDeleteRepositoryPipelineCacheRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	cacheUuid string
}


func (r PipelinesApiApiDeleteRepositoryPipelineCacheRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteRepositoryPipelineCacheExecute(r)
}

/*
 * DeleteRepositoryPipelineCache Method for DeleteRepositoryPipelineCache
 * Delete a repository cache.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace The account.
 * @param repoSlug The repository.
 * @param cacheUuid The UUID of the cache to delete.
 * @return PipelinesApiApiDeleteRepositoryPipelineCacheRequest
 */
func (a *PipelinesApiService) DeleteRepositoryPipelineCache(ctx _context.Context, workspace string, repoSlug string, cacheUuid string) PipelinesApiApiDeleteRepositoryPipelineCacheRequest {
	return PipelinesApiApiDeleteRepositoryPipelineCacheRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		cacheUuid: cacheUuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PipelinesApiService) DeleteRepositoryPipelineCacheExecute(r PipelinesApiApiDeleteRepositoryPipelineCacheRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteRepositoryPipelineCache")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cache_uuid"+"}", _neturl.PathEscape(parameterToString(r.cacheUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiApiDeleteRepositoryPipelineKeyPairRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
}


func (r PipelinesApiApiDeleteRepositoryPipelineKeyPairRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteRepositoryPipelineKeyPairExecute(r)
}

/*
 * DeleteRepositoryPipelineKeyPair Method for DeleteRepositoryPipelineKeyPair
 * Delete the repository SSH key pair.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiDeleteRepositoryPipelineKeyPairRequest
 */
func (a *PipelinesApiService) DeleteRepositoryPipelineKeyPair(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiDeleteRepositoryPipelineKeyPairRequest {
	return PipelinesApiApiDeleteRepositoryPipelineKeyPairRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 */
func (a *PipelinesApiService) DeleteRepositoryPipelineKeyPairExecute(r PipelinesApiApiDeleteRepositoryPipelineKeyPairRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteRepositoryPipelineKeyPair")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiApiDeleteRepositoryPipelineKnownHostRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	knownHostUuid string
}


func (r PipelinesApiApiDeleteRepositoryPipelineKnownHostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteRepositoryPipelineKnownHostExecute(r)
}

/*
 * DeleteRepositoryPipelineKnownHost Method for DeleteRepositoryPipelineKnownHost
 * Delete a repository level known host.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param knownHostUuid The UUID of the known host to delete.
 * @return PipelinesApiApiDeleteRepositoryPipelineKnownHostRequest
 */
func (a *PipelinesApiService) DeleteRepositoryPipelineKnownHost(ctx _context.Context, workspace string, repoSlug string, knownHostUuid string) PipelinesApiApiDeleteRepositoryPipelineKnownHostRequest {
	return PipelinesApiApiDeleteRepositoryPipelineKnownHostRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		knownHostUuid: knownHostUuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PipelinesApiService) DeleteRepositoryPipelineKnownHostExecute(r PipelinesApiApiDeleteRepositoryPipelineKnownHostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteRepositoryPipelineKnownHost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"known_host_uuid"+"}", _neturl.PathEscape(parameterToString(r.knownHostUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiApiDeleteRepositoryPipelineScheduleRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	scheduleUuid string
}


func (r PipelinesApiApiDeleteRepositoryPipelineScheduleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteRepositoryPipelineScheduleExecute(r)
}

/*
 * DeleteRepositoryPipelineSchedule Method for DeleteRepositoryPipelineSchedule
 * Delete a schedule.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param scheduleUuid The uuid of the schedule.
 * @return PipelinesApiApiDeleteRepositoryPipelineScheduleRequest
 */
func (a *PipelinesApiService) DeleteRepositoryPipelineSchedule(ctx _context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiApiDeleteRepositoryPipelineScheduleRequest {
	return PipelinesApiApiDeleteRepositoryPipelineScheduleRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		scheduleUuid: scheduleUuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PipelinesApiService) DeleteRepositoryPipelineScheduleExecute(r PipelinesApiApiDeleteRepositoryPipelineScheduleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteRepositoryPipelineSchedule")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_uuid"+"}", _neturl.PathEscape(parameterToString(r.scheduleUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiApiDeleteRepositoryPipelineVariableRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	variableUuid string
}


func (r PipelinesApiApiDeleteRepositoryPipelineVariableRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteRepositoryPipelineVariableExecute(r)
}

/*
 * DeleteRepositoryPipelineVariable Method for DeleteRepositoryPipelineVariable
 * Delete a repository level variable.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param variableUuid The UUID of the variable to delete.
 * @return PipelinesApiApiDeleteRepositoryPipelineVariableRequest
 */
func (a *PipelinesApiService) DeleteRepositoryPipelineVariable(ctx _context.Context, workspace string, repoSlug string, variableUuid string) PipelinesApiApiDeleteRepositoryPipelineVariableRequest {
	return PipelinesApiApiDeleteRepositoryPipelineVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PipelinesApiService) DeleteRepositoryPipelineVariableExecute(r PipelinesApiApiDeleteRepositoryPipelineVariableRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteRepositoryPipelineVariable")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiApiGetDeploymentVariablesRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	environmentUuid string
}


func (r PipelinesApiApiGetDeploymentVariablesRequest) Execute() (PaginatedDeploymentVariable, *_nethttp.Response, error) {
	return r.ApiService.GetDeploymentVariablesExecute(r)
}

/*
 * GetDeploymentVariables Method for GetDeploymentVariables
 * Find deployment environment level variables.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param environmentUuid The environment.
 * @return PipelinesApiApiGetDeploymentVariablesRequest
 */
func (a *PipelinesApiService) GetDeploymentVariables(ctx _context.Context, workspace string, repoSlug string, environmentUuid string) PipelinesApiApiGetDeploymentVariablesRequest {
	return PipelinesApiApiGetDeploymentVariablesRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		environmentUuid: environmentUuid,
	}
}

/*
 * Execute executes the request
 * @return PaginatedDeploymentVariable
 */
func (a *PipelinesApiService) GetDeploymentVariablesExecute(r PipelinesApiApiGetDeploymentVariablesRequest) (PaginatedDeploymentVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedDeploymentVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetDeploymentVariables")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_uuid"+"}", _neturl.PathEscape(parameterToString(r.environmentUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetPipelineForRepositoryRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	pipelineUuid string
}


func (r PipelinesApiApiGetPipelineForRepositoryRequest) Execute() (Pipeline, *_nethttp.Response, error) {
	return r.ApiService.GetPipelineForRepositoryExecute(r)
}

/*
 * GetPipelineForRepository Method for GetPipelineForRepository
 * Retrieve a specified pipeline
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param pipelineUuid The pipeline UUID.
 * @return PipelinesApiApiGetPipelineForRepositoryRequest
 */
func (a *PipelinesApiService) GetPipelineForRepository(ctx _context.Context, workspace string, repoSlug string, pipelineUuid string) PipelinesApiApiGetPipelineForRepositoryRequest {
	return PipelinesApiApiGetPipelineForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
	}
}

/*
 * Execute executes the request
 * @return Pipeline
 */
func (a *PipelinesApiService) GetPipelineForRepositoryExecute(r PipelinesApiApiGetPipelineForRepositoryRequest) (Pipeline, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Pipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineForRepository")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", _neturl.PathEscape(parameterToString(r.pipelineUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetPipelineStepForRepositoryRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	pipelineUuid string
	stepUuid string
}


func (r PipelinesApiApiGetPipelineStepForRepositoryRequest) Execute() (PipelineStep, *_nethttp.Response, error) {
	return r.ApiService.GetPipelineStepForRepositoryExecute(r)
}

/*
 * GetPipelineStepForRepository Method for GetPipelineStepForRepository
 * Retrieve a given step of a pipeline.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param pipelineUuid The UUID of the pipeline.
 * @param stepUuid The UUID of the step.
 * @return PipelinesApiApiGetPipelineStepForRepositoryRequest
 */
func (a *PipelinesApiService) GetPipelineStepForRepository(ctx _context.Context, workspace string, repoSlug string, pipelineUuid string, stepUuid string) PipelinesApiApiGetPipelineStepForRepositoryRequest {
	return PipelinesApiApiGetPipelineStepForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
		stepUuid: stepUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineStep
 */
func (a *PipelinesApiService) GetPipelineStepForRepositoryExecute(r PipelinesApiApiGetPipelineStepForRepositoryRequest) (PipelineStep, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineStepForRepository")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", _neturl.PathEscape(parameterToString(r.pipelineUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step_uuid"+"}", _neturl.PathEscape(parameterToString(r.stepUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetPipelineStepLogForRepositoryRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	pipelineUuid string
	stepUuid string
}


func (r PipelinesApiApiGetPipelineStepLogForRepositoryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetPipelineStepLogForRepositoryExecute(r)
}

/*
 * GetPipelineStepLogForRepository Method for GetPipelineStepLogForRepository
 * Retrieve the log file for a given step of a pipeline.

This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param pipelineUuid The UUID of the pipeline.
 * @param stepUuid The UUID of the step.
 * @return PipelinesApiApiGetPipelineStepLogForRepositoryRequest
 */
func (a *PipelinesApiService) GetPipelineStepLogForRepository(ctx _context.Context, workspace string, repoSlug string, pipelineUuid string, stepUuid string) PipelinesApiApiGetPipelineStepLogForRepositoryRequest {
	return PipelinesApiApiGetPipelineStepLogForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
		stepUuid: stepUuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PipelinesApiService) GetPipelineStepLogForRepositoryExecute(r PipelinesApiApiGetPipelineStepLogForRepositoryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineStepLogForRepository")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", _neturl.PathEscape(parameterToString(r.pipelineUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step_uuid"+"}", _neturl.PathEscape(parameterToString(r.stepUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 304 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 416 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiApiGetPipelineStepsForRepositoryRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	pipelineUuid string
}


func (r PipelinesApiApiGetPipelineStepsForRepositoryRequest) Execute() (PaginatedPipelineSteps, *_nethttp.Response, error) {
	return r.ApiService.GetPipelineStepsForRepositoryExecute(r)
}

/*
 * GetPipelineStepsForRepository Method for GetPipelineStepsForRepository
 * Find steps for the given pipeline.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param pipelineUuid The UUID of the pipeline.
 * @return PipelinesApiApiGetPipelineStepsForRepositoryRequest
 */
func (a *PipelinesApiService) GetPipelineStepsForRepository(ctx _context.Context, workspace string, repoSlug string, pipelineUuid string) PipelinesApiApiGetPipelineStepsForRepositoryRequest {
	return PipelinesApiApiGetPipelineStepsForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPipelineSteps
 */
func (a *PipelinesApiService) GetPipelineStepsForRepositoryExecute(r PipelinesApiApiGetPipelineStepsForRepositoryRequest) (PaginatedPipelineSteps, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPipelineSteps
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineStepsForRepository")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", _neturl.PathEscape(parameterToString(r.pipelineUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetPipelineVariableForTeamRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	username string
	variableUuid string
}


func (r PipelinesApiApiGetPipelineVariableForTeamRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.GetPipelineVariableForTeamExecute(r)
}

/*
 * GetPipelineVariableForTeam Method for GetPipelineVariableForTeam
 * Retrieve a team level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param username The account.
 * @param variableUuid The UUID of the variable to retrieve.
 * @return PipelinesApiApiGetPipelineVariableForTeamRequest
 */
func (a *PipelinesApiService) GetPipelineVariableForTeam(ctx _context.Context, username string, variableUuid string) PipelinesApiApiGetPipelineVariableForTeamRequest {
	return PipelinesApiApiGetPipelineVariableForTeamRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) GetPipelineVariableForTeamExecute(r PipelinesApiApiGetPipelineVariableForTeamRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariableForTeam")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{username}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", _neturl.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetPipelineVariableForUserRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	selectedUser string
	variableUuid string
}


func (r PipelinesApiApiGetPipelineVariableForUserRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.GetPipelineVariableForUserExecute(r)
}

/*
 * GetPipelineVariableForUser Method for GetPipelineVariableForUser
 * Retrieve a user level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
 * @param variableUuid The UUID of the variable to retrieve.
 * @return PipelinesApiApiGetPipelineVariableForUserRequest
 */
func (a *PipelinesApiService) GetPipelineVariableForUser(ctx _context.Context, selectedUser string, variableUuid string) PipelinesApiApiGetPipelineVariableForUserRequest {
	return PipelinesApiApiGetPipelineVariableForUserRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) GetPipelineVariableForUserExecute(r PipelinesApiApiGetPipelineVariableForUserRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariableForUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{selected_user}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", _neturl.PathEscape(parameterToString(r.selectedUser, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetPipelineVariableForWorkspaceRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	variableUuid string
}


func (r PipelinesApiApiGetPipelineVariableForWorkspaceRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.GetPipelineVariableForWorkspaceExecute(r)
}

/*
 * GetPipelineVariableForWorkspace Method for GetPipelineVariableForWorkspace
 * Retrieve a workspace level variable.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param variableUuid The UUID of the variable to retrieve.
 * @return PipelinesApiApiGetPipelineVariableForWorkspaceRequest
 */
func (a *PipelinesApiService) GetPipelineVariableForWorkspace(ctx _context.Context, workspace string, variableUuid string) PipelinesApiApiGetPipelineVariableForWorkspaceRequest {
	return PipelinesApiApiGetPipelineVariableForWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) GetPipelineVariableForWorkspaceExecute(r PipelinesApiApiGetPipelineVariableForWorkspaceRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariableForWorkspace")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetPipelineVariablesForTeamRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	username string
}


func (r PipelinesApiApiGetPipelineVariablesForTeamRequest) Execute() (PaginatedPipelineVariables, *_nethttp.Response, error) {
	return r.ApiService.GetPipelineVariablesForTeamExecute(r)
}

/*
 * GetPipelineVariablesForTeam Method for GetPipelineVariablesForTeam
 * Find account level variables.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param username This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @return PipelinesApiApiGetPipelineVariablesForTeamRequest
 */
func (a *PipelinesApiService) GetPipelineVariablesForTeam(ctx _context.Context, username string) PipelinesApiApiGetPipelineVariablesForTeamRequest {
	return PipelinesApiApiGetPipelineVariablesForTeamRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPipelineVariables
 */
func (a *PipelinesApiService) GetPipelineVariablesForTeamExecute(r PipelinesApiApiGetPipelineVariablesForTeamRequest) (PaginatedPipelineVariables, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPipelineVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariablesForTeam")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{username}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", _neturl.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetPipelineVariablesForUserRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	selectedUser string
}


func (r PipelinesApiApiGetPipelineVariablesForUserRequest) Execute() (PaginatedPipelineVariables, *_nethttp.Response, error) {
	return r.ApiService.GetPipelineVariablesForUserExecute(r)
}

/*
 * GetPipelineVariablesForUser Method for GetPipelineVariablesForUser
 * Find user level variables.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
 * @return PipelinesApiApiGetPipelineVariablesForUserRequest
 */
func (a *PipelinesApiService) GetPipelineVariablesForUser(ctx _context.Context, selectedUser string) PipelinesApiApiGetPipelineVariablesForUserRequest {
	return PipelinesApiApiGetPipelineVariablesForUserRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPipelineVariables
 */
func (a *PipelinesApiService) GetPipelineVariablesForUserExecute(r PipelinesApiApiGetPipelineVariablesForUserRequest) (PaginatedPipelineVariables, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPipelineVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariablesForUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{selected_user}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", _neturl.PathEscape(parameterToString(r.selectedUser, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetPipelineVariablesForWorkspaceRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
}


func (r PipelinesApiApiGetPipelineVariablesForWorkspaceRequest) Execute() (PaginatedPipelineVariables, *_nethttp.Response, error) {
	return r.ApiService.GetPipelineVariablesForWorkspaceExecute(r)
}

/*
 * GetPipelineVariablesForWorkspace Method for GetPipelineVariablesForWorkspace
 * Find workspace level variables.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @return PipelinesApiApiGetPipelineVariablesForWorkspaceRequest
 */
func (a *PipelinesApiService) GetPipelineVariablesForWorkspace(ctx _context.Context, workspace string) PipelinesApiApiGetPipelineVariablesForWorkspaceRequest {
	return PipelinesApiApiGetPipelineVariablesForWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPipelineVariables
 */
func (a *PipelinesApiService) GetPipelineVariablesForWorkspaceExecute(r PipelinesApiApiGetPipelineVariablesForWorkspaceRequest) (PaginatedPipelineVariables, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPipelineVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariablesForWorkspace")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetPipelinesForRepositoryRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
}


func (r PipelinesApiApiGetPipelinesForRepositoryRequest) Execute() (PaginatedPipelines, *_nethttp.Response, error) {
	return r.ApiService.GetPipelinesForRepositoryExecute(r)
}

/*
 * GetPipelinesForRepository Method for GetPipelinesForRepository
 * Find pipelines
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiGetPipelinesForRepositoryRequest
 */
func (a *PipelinesApiService) GetPipelinesForRepository(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetPipelinesForRepositoryRequest {
	return PipelinesApiApiGetPipelinesForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPipelines
 */
func (a *PipelinesApiService) GetPipelinesForRepositoryExecute(r PipelinesApiApiGetPipelinesForRepositoryRequest) (PaginatedPipelines, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPipelines
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelinesForRepository")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetRepositoryPipelineCacheContentURIRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	cacheUuid string
}


func (r PipelinesApiApiGetRepositoryPipelineCacheContentURIRequest) Execute() (PipelineCacheContentUri, *_nethttp.Response, error) {
	return r.ApiService.GetRepositoryPipelineCacheContentURIExecute(r)
}

/*
 * GetRepositoryPipelineCacheContentURI Method for GetRepositoryPipelineCacheContentURI
 * Retrieve the URI of the content of the specified cache.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace The account.
 * @param repoSlug The repository.
 * @param cacheUuid The UUID of the cache.
 * @return PipelinesApiApiGetRepositoryPipelineCacheContentURIRequest
 */
func (a *PipelinesApiService) GetRepositoryPipelineCacheContentURI(ctx _context.Context, workspace string, repoSlug string, cacheUuid string) PipelinesApiApiGetRepositoryPipelineCacheContentURIRequest {
	return PipelinesApiApiGetRepositoryPipelineCacheContentURIRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		cacheUuid: cacheUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineCacheContentUri
 */
func (a *PipelinesApiService) GetRepositoryPipelineCacheContentURIExecute(r PipelinesApiApiGetRepositoryPipelineCacheContentURIRequest) (PipelineCacheContentUri, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineCacheContentUri
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineCacheContentURI")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}/content-uri"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cache_uuid"+"}", _neturl.PathEscape(parameterToString(r.cacheUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetRepositoryPipelineCachesRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
}


func (r PipelinesApiApiGetRepositoryPipelineCachesRequest) Execute() (PaginatedPipelineCaches, *_nethttp.Response, error) {
	return r.ApiService.GetRepositoryPipelineCachesExecute(r)
}

/*
 * GetRepositoryPipelineCaches Method for GetRepositoryPipelineCaches
 * Retrieve the repository pipelines caches.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace The account.
 * @param repoSlug The repository.
 * @return PipelinesApiApiGetRepositoryPipelineCachesRequest
 */
func (a *PipelinesApiService) GetRepositoryPipelineCaches(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineCachesRequest {
	return PipelinesApiApiGetRepositoryPipelineCachesRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPipelineCaches
 */
func (a *PipelinesApiService) GetRepositoryPipelineCachesExecute(r PipelinesApiApiGetRepositoryPipelineCachesRequest) (PaginatedPipelineCaches, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPipelineCaches
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineCaches")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines-config/caches/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetRepositoryPipelineConfigRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
}


func (r PipelinesApiApiGetRepositoryPipelineConfigRequest) Execute() (PipelinesConfig, *_nethttp.Response, error) {
	return r.ApiService.GetRepositoryPipelineConfigExecute(r)
}

/*
 * GetRepositoryPipelineConfig Method for GetRepositoryPipelineConfig
 * Retrieve the repository pipelines configuration.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace The account.
 * @param repoSlug The repository.
 * @return PipelinesApiApiGetRepositoryPipelineConfigRequest
 */
func (a *PipelinesApiService) GetRepositoryPipelineConfig(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineConfigRequest {
	return PipelinesApiApiGetRepositoryPipelineConfigRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PipelinesConfig
 */
func (a *PipelinesApiService) GetRepositoryPipelineConfigExecute(r PipelinesApiApiGetRepositoryPipelineConfigRequest) (PipelinesConfig, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelinesConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetRepositoryPipelineKnownHostRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	knownHostUuid string
}


func (r PipelinesApiApiGetRepositoryPipelineKnownHostRequest) Execute() (PipelineKnownHost, *_nethttp.Response, error) {
	return r.ApiService.GetRepositoryPipelineKnownHostExecute(r)
}

/*
 * GetRepositoryPipelineKnownHost Method for GetRepositoryPipelineKnownHost
 * Retrieve a repository level known host.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param knownHostUuid The UUID of the known host to retrieve.
 * @return PipelinesApiApiGetRepositoryPipelineKnownHostRequest
 */
func (a *PipelinesApiService) GetRepositoryPipelineKnownHost(ctx _context.Context, workspace string, repoSlug string, knownHostUuid string) PipelinesApiApiGetRepositoryPipelineKnownHostRequest {
	return PipelinesApiApiGetRepositoryPipelineKnownHostRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		knownHostUuid: knownHostUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineKnownHost
 */
func (a *PipelinesApiService) GetRepositoryPipelineKnownHostExecute(r PipelinesApiApiGetRepositoryPipelineKnownHostRequest) (PipelineKnownHost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineKnownHost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineKnownHost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"known_host_uuid"+"}", _neturl.PathEscape(parameterToString(r.knownHostUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetRepositoryPipelineKnownHostsRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
}


func (r PipelinesApiApiGetRepositoryPipelineKnownHostsRequest) Execute() (PaginatedPipelineKnownHosts, *_nethttp.Response, error) {
	return r.ApiService.GetRepositoryPipelineKnownHostsExecute(r)
}

/*
 * GetRepositoryPipelineKnownHosts Method for GetRepositoryPipelineKnownHosts
 * Find repository level known hosts.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiGetRepositoryPipelineKnownHostsRequest
 */
func (a *PipelinesApiService) GetRepositoryPipelineKnownHosts(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineKnownHostsRequest {
	return PipelinesApiApiGetRepositoryPipelineKnownHostsRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPipelineKnownHosts
 */
func (a *PipelinesApiService) GetRepositoryPipelineKnownHostsExecute(r PipelinesApiApiGetRepositoryPipelineKnownHostsRequest) (PaginatedPipelineKnownHosts, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPipelineKnownHosts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineKnownHosts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetRepositoryPipelineScheduleRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	scheduleUuid string
}


func (r PipelinesApiApiGetRepositoryPipelineScheduleRequest) Execute() (PipelineSchedule, *_nethttp.Response, error) {
	return r.ApiService.GetRepositoryPipelineScheduleExecute(r)
}

/*
 * GetRepositoryPipelineSchedule Method for GetRepositoryPipelineSchedule
 * Retrieve a schedule by its UUID.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param scheduleUuid The uuid of the schedule.
 * @return PipelinesApiApiGetRepositoryPipelineScheduleRequest
 */
func (a *PipelinesApiService) GetRepositoryPipelineSchedule(ctx _context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiApiGetRepositoryPipelineScheduleRequest {
	return PipelinesApiApiGetRepositoryPipelineScheduleRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		scheduleUuid: scheduleUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineSchedule
 */
func (a *PipelinesApiService) GetRepositoryPipelineScheduleExecute(r PipelinesApiApiGetRepositoryPipelineScheduleRequest) (PipelineSchedule, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineSchedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_uuid"+"}", _neturl.PathEscape(parameterToString(r.scheduleUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetRepositoryPipelineScheduleExecutionsRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	scheduleUuid string
}


func (r PipelinesApiApiGetRepositoryPipelineScheduleExecutionsRequest) Execute() (PaginatedPipelineScheduleExecutions, *_nethttp.Response, error) {
	return r.ApiService.GetRepositoryPipelineScheduleExecutionsExecute(r)
}

/*
 * GetRepositoryPipelineScheduleExecutions Method for GetRepositoryPipelineScheduleExecutions
 * Retrieve the executions of a given schedule.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param scheduleUuid schedule_uuid
 * @return PipelinesApiApiGetRepositoryPipelineScheduleExecutionsRequest
 */
func (a *PipelinesApiService) GetRepositoryPipelineScheduleExecutions(ctx _context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiApiGetRepositoryPipelineScheduleExecutionsRequest {
	return PipelinesApiApiGetRepositoryPipelineScheduleExecutionsRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		scheduleUuid: scheduleUuid,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPipelineScheduleExecutions
 */
func (a *PipelinesApiService) GetRepositoryPipelineScheduleExecutionsExecute(r PipelinesApiApiGetRepositoryPipelineScheduleExecutionsRequest) (PaginatedPipelineScheduleExecutions, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPipelineScheduleExecutions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineScheduleExecutions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}/executions/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_uuid"+"}", _neturl.PathEscape(parameterToString(r.scheduleUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetRepositoryPipelineSchedulesRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
}


func (r PipelinesApiApiGetRepositoryPipelineSchedulesRequest) Execute() (PaginatedPipelineSchedules, *_nethttp.Response, error) {
	return r.ApiService.GetRepositoryPipelineSchedulesExecute(r)
}

/*
 * GetRepositoryPipelineSchedules Method for GetRepositoryPipelineSchedules
 * Retrieve the configured schedules for the given repository.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiGetRepositoryPipelineSchedulesRequest
 */
func (a *PipelinesApiService) GetRepositoryPipelineSchedules(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineSchedulesRequest {
	return PipelinesApiApiGetRepositoryPipelineSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPipelineSchedules
 */
func (a *PipelinesApiService) GetRepositoryPipelineSchedulesExecute(r PipelinesApiApiGetRepositoryPipelineSchedulesRequest) (PaginatedPipelineSchedules, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPipelineSchedules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineSchedules")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetRepositoryPipelineSshKeyPairRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
}


func (r PipelinesApiApiGetRepositoryPipelineSshKeyPairRequest) Execute() (PipelineSshKeyPair, *_nethttp.Response, error) {
	return r.ApiService.GetRepositoryPipelineSshKeyPairExecute(r)
}

/*
 * GetRepositoryPipelineSshKeyPair Method for GetRepositoryPipelineSshKeyPair
 * Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiGetRepositoryPipelineSshKeyPairRequest
 */
func (a *PipelinesApiService) GetRepositoryPipelineSshKeyPair(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineSshKeyPairRequest {
	return PipelinesApiApiGetRepositoryPipelineSshKeyPairRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PipelineSshKeyPair
 */
func (a *PipelinesApiService) GetRepositoryPipelineSshKeyPairExecute(r PipelinesApiApiGetRepositoryPipelineSshKeyPairRequest) (PipelineSshKeyPair, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineSshKeyPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineSshKeyPair")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetRepositoryPipelineVariableRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	variableUuid string
}


func (r PipelinesApiApiGetRepositoryPipelineVariableRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.GetRepositoryPipelineVariableExecute(r)
}

/*
 * GetRepositoryPipelineVariable Method for GetRepositoryPipelineVariable
 * Retrieve a repository level variable.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param variableUuid The UUID of the variable to retrieve.
 * @return PipelinesApiApiGetRepositoryPipelineVariableRequest
 */
func (a *PipelinesApiService) GetRepositoryPipelineVariable(ctx _context.Context, workspace string, repoSlug string, variableUuid string) PipelinesApiApiGetRepositoryPipelineVariableRequest {
	return PipelinesApiApiGetRepositoryPipelineVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) GetRepositoryPipelineVariableExecute(r PipelinesApiApiGetRepositoryPipelineVariableRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineVariable")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiGetRepositoryPipelineVariablesRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
}


func (r PipelinesApiApiGetRepositoryPipelineVariablesRequest) Execute() (PaginatedPipelineVariables, *_nethttp.Response, error) {
	return r.ApiService.GetRepositoryPipelineVariablesExecute(r)
}

/*
 * GetRepositoryPipelineVariables Method for GetRepositoryPipelineVariables
 * Find repository level variables.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiGetRepositoryPipelineVariablesRequest
 */
func (a *PipelinesApiService) GetRepositoryPipelineVariables(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiGetRepositoryPipelineVariablesRequest {
	return PipelinesApiApiGetRepositoryPipelineVariablesRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPipelineVariables
 */
func (a *PipelinesApiService) GetRepositoryPipelineVariablesExecute(r PipelinesApiApiGetRepositoryPipelineVariablesRequest) (PaginatedPipelineVariables, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPipelineVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineVariables")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiStopPipelineRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	pipelineUuid string
}


func (r PipelinesApiApiStopPipelineRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.StopPipelineExecute(r)
}

/*
 * StopPipeline Method for StopPipeline
 * Signal the stop of a pipeline and all of its steps that not have completed yet.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param pipelineUuid The UUID of the pipeline.
 * @return PipelinesApiApiStopPipelineRequest
 */
func (a *PipelinesApiService) StopPipeline(ctx _context.Context, workspace string, repoSlug string, pipelineUuid string) PipelinesApiApiStopPipelineRequest {
	return PipelinesApiApiStopPipelineRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PipelinesApiService) StopPipelineExecute(r PipelinesApiApiStopPipelineRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.StopPipeline")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/stopPipeline"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", _neturl.PathEscape(parameterToString(r.pipelineUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiApiUpdateDeploymentVariableRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	environmentUuid string
	variableUuid string
	body *DeploymentVariable
}

func (r PipelinesApiApiUpdateDeploymentVariableRequest) Body(body DeploymentVariable) PipelinesApiApiUpdateDeploymentVariableRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiUpdateDeploymentVariableRequest) Execute() (DeploymentVariable, *_nethttp.Response, error) {
	return r.ApiService.UpdateDeploymentVariableExecute(r)
}

/*
 * UpdateDeploymentVariable Method for UpdateDeploymentVariable
 * Update a deployment environment level variable.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param environmentUuid The environment.
 * @param variableUuid The UUID of the variable to update.
 * @return PipelinesApiApiUpdateDeploymentVariableRequest
 */
func (a *PipelinesApiService) UpdateDeploymentVariable(ctx _context.Context, workspace string, repoSlug string, environmentUuid string, variableUuid string) PipelinesApiApiUpdateDeploymentVariableRequest {
	return PipelinesApiApiUpdateDeploymentVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		environmentUuid: environmentUuid,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 * @return DeploymentVariable
 */
func (a *PipelinesApiService) UpdateDeploymentVariableExecute(r PipelinesApiApiUpdateDeploymentVariableRequest) (DeploymentVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeploymentVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateDeploymentVariable")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_uuid"+"}", _neturl.PathEscape(parameterToString(r.environmentUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiUpdatePipelineVariableForTeamRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	username string
	variableUuid string
	body *PipelineVariable
}

func (r PipelinesApiApiUpdatePipelineVariableForTeamRequest) Body(body PipelineVariable) PipelinesApiApiUpdatePipelineVariableForTeamRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiUpdatePipelineVariableForTeamRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.UpdatePipelineVariableForTeamExecute(r)
}

/*
 * UpdatePipelineVariableForTeam Method for UpdatePipelineVariableForTeam
 * Update a team level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param username The account.
 * @param variableUuid The UUID of the variable.
 * @return PipelinesApiApiUpdatePipelineVariableForTeamRequest
 */
func (a *PipelinesApiService) UpdatePipelineVariableForTeam(ctx _context.Context, username string, variableUuid string) PipelinesApiApiUpdatePipelineVariableForTeamRequest {
	return PipelinesApiApiUpdatePipelineVariableForTeamRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) UpdatePipelineVariableForTeamExecute(r PipelinesApiApiUpdatePipelineVariableForTeamRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdatePipelineVariableForTeam")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{username}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", _neturl.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiUpdatePipelineVariableForUserRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	selectedUser string
	variableUuid string
	body *PipelineVariable
}

func (r PipelinesApiApiUpdatePipelineVariableForUserRequest) Body(body PipelineVariable) PipelinesApiApiUpdatePipelineVariableForUserRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiUpdatePipelineVariableForUserRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.UpdatePipelineVariableForUserExecute(r)
}

/*
 * UpdatePipelineVariableForUser Method for UpdatePipelineVariableForUser
 * Update a user level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
 * @param variableUuid The UUID of the variable.
 * @return PipelinesApiApiUpdatePipelineVariableForUserRequest
 */
func (a *PipelinesApiService) UpdatePipelineVariableForUser(ctx _context.Context, selectedUser string, variableUuid string) PipelinesApiApiUpdatePipelineVariableForUserRequest {
	return PipelinesApiApiUpdatePipelineVariableForUserRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) UpdatePipelineVariableForUserExecute(r PipelinesApiApiUpdatePipelineVariableForUserRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdatePipelineVariableForUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{selected_user}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", _neturl.PathEscape(parameterToString(r.selectedUser, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiUpdatePipelineVariableForWorkspaceRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	variableUuid string
	body *PipelineVariable
}

func (r PipelinesApiApiUpdatePipelineVariableForWorkspaceRequest) Body(body PipelineVariable) PipelinesApiApiUpdatePipelineVariableForWorkspaceRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiUpdatePipelineVariableForWorkspaceRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.UpdatePipelineVariableForWorkspaceExecute(r)
}

/*
 * UpdatePipelineVariableForWorkspace Method for UpdatePipelineVariableForWorkspace
 * Update a workspace level variable.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param variableUuid The UUID of the variable.
 * @return PipelinesApiApiUpdatePipelineVariableForWorkspaceRequest
 */
func (a *PipelinesApiService) UpdatePipelineVariableForWorkspace(ctx _context.Context, workspace string, variableUuid string) PipelinesApiApiUpdatePipelineVariableForWorkspaceRequest {
	return PipelinesApiApiUpdatePipelineVariableForWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) UpdatePipelineVariableForWorkspaceExecute(r PipelinesApiApiUpdatePipelineVariableForWorkspaceRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdatePipelineVariableForWorkspace")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiUpdateRepositoryBuildNumberRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	body *PipelineBuildNumber
}

func (r PipelinesApiApiUpdateRepositoryBuildNumberRequest) Body(body PipelineBuildNumber) PipelinesApiApiUpdateRepositoryBuildNumberRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiUpdateRepositoryBuildNumberRequest) Execute() (PipelineBuildNumber, *_nethttp.Response, error) {
	return r.ApiService.UpdateRepositoryBuildNumberExecute(r)
}

/*
 * UpdateRepositoryBuildNumber Method for UpdateRepositoryBuildNumber
 * Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiUpdateRepositoryBuildNumberRequest
 */
func (a *PipelinesApiService) UpdateRepositoryBuildNumber(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiUpdateRepositoryBuildNumberRequest {
	return PipelinesApiApiUpdateRepositoryBuildNumberRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PipelineBuildNumber
 */
func (a *PipelinesApiService) UpdateRepositoryBuildNumberExecute(r PipelinesApiApiUpdateRepositoryBuildNumberRequest) (PipelineBuildNumber, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineBuildNumber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryBuildNumber")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/build_number"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiUpdateRepositoryPipelineConfigRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	body *PipelinesConfig
}

func (r PipelinesApiApiUpdateRepositoryPipelineConfigRequest) Body(body PipelinesConfig) PipelinesApiApiUpdateRepositoryPipelineConfigRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiUpdateRepositoryPipelineConfigRequest) Execute() (PipelinesConfig, *_nethttp.Response, error) {
	return r.ApiService.UpdateRepositoryPipelineConfigExecute(r)
}

/*
 * UpdateRepositoryPipelineConfig Method for UpdateRepositoryPipelineConfig
 * Update the pipelines configuration for a repository.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiUpdateRepositoryPipelineConfigRequest
 */
func (a *PipelinesApiService) UpdateRepositoryPipelineConfig(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiUpdateRepositoryPipelineConfigRequest {
	return PipelinesApiApiUpdateRepositoryPipelineConfigRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PipelinesConfig
 */
func (a *PipelinesApiService) UpdateRepositoryPipelineConfigExecute(r PipelinesApiApiUpdateRepositoryPipelineConfigRequest) (PipelinesConfig, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelinesConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryPipelineConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiUpdateRepositoryPipelineKeyPairRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	body *PipelineSshKeyPair
}

func (r PipelinesApiApiUpdateRepositoryPipelineKeyPairRequest) Body(body PipelineSshKeyPair) PipelinesApiApiUpdateRepositoryPipelineKeyPairRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiUpdateRepositoryPipelineKeyPairRequest) Execute() (PipelineSshKeyPair, *_nethttp.Response, error) {
	return r.ApiService.UpdateRepositoryPipelineKeyPairExecute(r)
}

/*
 * UpdateRepositoryPipelineKeyPair Method for UpdateRepositoryPipelineKeyPair
 * Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @return PipelinesApiApiUpdateRepositoryPipelineKeyPairRequest
 */
func (a *PipelinesApiService) UpdateRepositoryPipelineKeyPair(ctx _context.Context, workspace string, repoSlug string) PipelinesApiApiUpdateRepositoryPipelineKeyPairRequest {
	return PipelinesApiApiUpdateRepositoryPipelineKeyPairRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

/*
 * Execute executes the request
 * @return PipelineSshKeyPair
 */
func (a *PipelinesApiService) UpdateRepositoryPipelineKeyPairExecute(r PipelinesApiApiUpdateRepositoryPipelineKeyPairRequest) (PipelineSshKeyPair, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineSshKeyPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryPipelineKeyPair")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiUpdateRepositoryPipelineKnownHostRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	knownHostUuid string
	body *PipelineKnownHost
}

func (r PipelinesApiApiUpdateRepositoryPipelineKnownHostRequest) Body(body PipelineKnownHost) PipelinesApiApiUpdateRepositoryPipelineKnownHostRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiUpdateRepositoryPipelineKnownHostRequest) Execute() (PipelineKnownHost, *_nethttp.Response, error) {
	return r.ApiService.UpdateRepositoryPipelineKnownHostExecute(r)
}

/*
 * UpdateRepositoryPipelineKnownHost Method for UpdateRepositoryPipelineKnownHost
 * Update a repository level known host.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param knownHostUuid The UUID of the known host to update.
 * @return PipelinesApiApiUpdateRepositoryPipelineKnownHostRequest
 */
func (a *PipelinesApiService) UpdateRepositoryPipelineKnownHost(ctx _context.Context, workspace string, repoSlug string, knownHostUuid string) PipelinesApiApiUpdateRepositoryPipelineKnownHostRequest {
	return PipelinesApiApiUpdateRepositoryPipelineKnownHostRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		knownHostUuid: knownHostUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineKnownHost
 */
func (a *PipelinesApiService) UpdateRepositoryPipelineKnownHostExecute(r PipelinesApiApiUpdateRepositoryPipelineKnownHostRequest) (PipelineKnownHost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineKnownHost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryPipelineKnownHost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"known_host_uuid"+"}", _neturl.PathEscape(parameterToString(r.knownHostUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiUpdateRepositoryPipelineScheduleRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	scheduleUuid string
	body *PipelineSchedule
}

func (r PipelinesApiApiUpdateRepositoryPipelineScheduleRequest) Body(body PipelineSchedule) PipelinesApiApiUpdateRepositoryPipelineScheduleRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiUpdateRepositoryPipelineScheduleRequest) Execute() (PipelineSchedule, *_nethttp.Response, error) {
	return r.ApiService.UpdateRepositoryPipelineScheduleExecute(r)
}

/*
 * UpdateRepositoryPipelineSchedule Method for UpdateRepositoryPipelineSchedule
 * Update a schedule.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param scheduleUuid The uuid of the schedule.
 * @return PipelinesApiApiUpdateRepositoryPipelineScheduleRequest
 */
func (a *PipelinesApiService) UpdateRepositoryPipelineSchedule(ctx _context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiApiUpdateRepositoryPipelineScheduleRequest {
	return PipelinesApiApiUpdateRepositoryPipelineScheduleRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		scheduleUuid: scheduleUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineSchedule
 */
func (a *PipelinesApiService) UpdateRepositoryPipelineScheduleExecute(r PipelinesApiApiUpdateRepositoryPipelineScheduleRequest) (PipelineSchedule, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineSchedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryPipelineSchedule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_uuid"+"}", _neturl.PathEscape(parameterToString(r.scheduleUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiApiUpdateRepositoryPipelineVariableRequest struct {
	ctx _context.Context
	ApiService PipelinesApi
	workspace string
	repoSlug string
	variableUuid string
	body *PipelineVariable
}

func (r PipelinesApiApiUpdateRepositoryPipelineVariableRequest) Body(body PipelineVariable) PipelinesApiApiUpdateRepositoryPipelineVariableRequest {
	r.body = &body
	return r
}

func (r PipelinesApiApiUpdateRepositoryPipelineVariableRequest) Execute() (PipelineVariable, *_nethttp.Response, error) {
	return r.ApiService.UpdateRepositoryPipelineVariableExecute(r)
}

/*
 * UpdateRepositoryPipelineVariable Method for UpdateRepositoryPipelineVariable
 * Update a repository level variable.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 * @param repoSlug The repository.
 * @param variableUuid The UUID of the variable to update.
 * @return PipelinesApiApiUpdateRepositoryPipelineVariableRequest
 */
func (a *PipelinesApiService) UpdateRepositoryPipelineVariable(ctx _context.Context, workspace string, repoSlug string, variableUuid string) PipelinesApiApiUpdateRepositoryPipelineVariableRequest {
	return PipelinesApiApiUpdateRepositoryPipelineVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		variableUuid: variableUuid,
	}
}

/*
 * Execute executes the request
 * @return PipelineVariable
 */
func (a *PipelinesApiService) UpdateRepositoryPipelineVariableExecute(r PipelinesApiApiUpdateRepositoryPipelineVariableRequest) (PipelineVariable, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryPipelineVariable")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", _neturl.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
