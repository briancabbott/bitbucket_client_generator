/*
 * Bitbucket API
 *
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * API version: 2.0
 * Contact: support@bitbucket.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bitbucket_client

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type PullrequestsApi interface {

	/*
	 * GetPullrequestsForCommit Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when 'Go to pull request' is clicked from the web interface for a commit's details.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces
	 * @param repoSlug The repository; either the UUID in curly braces, or the slug
	 * @param commit The SHA1 of the commit
	 * @return PullrequestsApiApiGetPullrequestsForCommitRequest
	 */
	GetPullrequestsForCommit(ctx _context.Context, workspace string, repoSlug string, commit string) PullrequestsApiApiGetPullrequestsForCommitRequest

	/*
	 * GetPullrequestsForCommitExecute executes the request
	 * @return PaginatedPullrequests
	 */
	GetPullrequestsForCommitExecute(r PullrequestsApiApiGetPullrequestsForCommitRequest) (PaginatedPullrequests, *_nethttp.Response, error)

	/*
	 * PullrequestsSelectedUserGet Method for PullrequestsSelectedUserGet
	 * Returns all pull requests authored by the specified user.

By default only open pull requests are returned. This can be controlled
using the `state` query parameter. To retrieve pull requests that are
in one of multiple states, repeat the `state` parameter for each
individual state.

This endpoint also supports filtering and sorting of the results. See
[filtering and sorting](../../../../meta/filtering) for more details.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param selectedUser This can either be the username of the pull request author, the author's UUID surrounded by curly-braces, for example: `{account UUID}`, or the author's Atlassian ID. 
	 * @return PullrequestsApiApiPullrequestsSelectedUserGetRequest
	 */
	PullrequestsSelectedUserGet(ctx _context.Context, selectedUser string) PullrequestsApiApiPullrequestsSelectedUserGetRequest

	/*
	 * PullrequestsSelectedUserGetExecute executes the request
	 * @return PaginatedPullrequests
	 */
	PullrequestsSelectedUserGetExecute(r PullrequestsApiApiPullrequestsSelectedUserGetRequest) (PaginatedPullrequests, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugDefaultReviewersGet Method for RepositoriesWorkspaceRepoSlugDefaultReviewersGet
	 * Returns the repository's default reviewers.

These are the users that are automatically added as reviewers on every
new pull request that is created.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest
	 */
	RepositoriesWorkspaceRepoSlugDefaultReviewersGet(ctx _context.Context, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugDefaultReviewersGetExecute executes the request
	 */
	RepositoriesWorkspaceRepoSlugDefaultReviewersGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest) (*_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete Method for RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete
	 * Removes a default reviewer from the repository.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest
	 */
	RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(ctx _context.Context, repoSlug string, targetUsername string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest

	/*
	 * RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteExecute executes the request
	 * @return ModelError
	 */
	RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest) (ModelError, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet Method for RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet
	 * Returns the specified reviewer.

This can be used to test whether a user is among the repository's
default reviewers list. A 404 indicates that that specified user is not
a default reviewer.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest
	 */
	RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(ctx _context.Context, repoSlug string, targetUsername string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetExecute executes the request
	 * @return ModelError
	 */
	RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest) (ModelError, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut Method for RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut
	 * Adds the specified user to the repository's list of default
reviewers.

This method is idempotent. Adding a user a second time has no effect.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest
	 */
	RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(ctx _context.Context, repoSlug string, targetUsername string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest

	/*
	 * RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutExecute executes the request
	 * @return ModelError
	 */
	RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest) (ModelError, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsActivityGet Method for RepositoriesWorkspaceRepoSlugPullrequestsActivityGet
	 * Returns a paginated list of the pull request's activity log.

This handler serves both a v20 and internal endpoint. The v20 endpoint
returns reviewer comments, updates, approvals and request changes. The internal
endpoint includes those plus tasks and attachments.

Comments created on a file or a line of code have an inline property.

Comment example:
```
{
    "pagelen": 20,
    "values": [
        {
            "comment": {
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088"
                    }
                },
                "deleted": false,
                "pullrequest": {
                    "type": "pullrequest",
                    "id": 5695,
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                        },
                        "html": {
                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                        }
                    },
                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
                },
                "content": {
                    "raw": "inline with to a dn from lines",
                    "markup": "markdown",
                    "html": "<p>inline with to a dn from lines</p>",
                    "type": "rendered"
                },
                "created_on": "2019-09-27T00:33:46.039178+00:00",
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "created_on": "2019-09-27T00:33:46.039178+00:00",
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "updated_on": "2019-09-27T00:33:46.055384+00:00",
                "inline": {
                    "context_lines": "",
                    "to": null,
                    "path": "",
                    "outdated": false,
                    "from": 211
                },
                "type": "pullrequest_comment",
                "id": 118571088
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```

Updates include a state property of OPEN, MERGED, or DECLINED.

Update example:
```
{
    "pagelen": 20,
    "values": [
        {
            "update": {
                "description": "",
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it",
                "destination": {
                    "commit": {
                        "type": "commit",
                        "hash": "6a2c16e4a152",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152"
                            }
                        }
                    },
                    "branch": {
                        "name": "master"
                    },
                    "repository": {
                        "name": "Atlaskit-MK-2",
                        "type": "repository",
                        "full_name": "atlassian/atlaskit-mk-2",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
                            },
                            "avatar": {
                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
                            }
                        },
                        "uuid": "{}"
                    }
                },
                "reason": "",
                "source": {
                    "commit": {
                        "type": "commit",
                        "hash": "728c8bad1813",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813"
                            }
                        }
                    },
                    "branch": {
                        "name": "username/NONE-add-onClick-prop-for-accessibility"
                    },
                    "repository": {
                        "name": "Atlaskit-MK-2",
                        "type": "repository",
                        "full_name": "atlassian/atlaskit-mk-2",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
                            },
                            "avatar": {
                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
                            }
                        },
                        "uuid": "{}"
                    }
                },
                "state": "OPEN",
                "author": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "date": "2019-05-10T06:48:25.305565+00:00"
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```

Approval example:
```
{
    "pagelen": 20,
    "values": [
        {
            "approval": {
                "date": "2019-09-27T00:37:19.849534+00:00",
                "pullrequest": {
                    "type": "pullrequest",
                    "id": 5695,
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                        },
                        "html": {
                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                        }
                    },
                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
                },
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                }
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsActivityGet(ctx _context.Context, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsActivityGetExecute executes the request
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsActivityGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest) (*_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsGet Method for RepositoriesWorkspaceRepoSlugPullrequestsGet
	 * Returns all pull requests on the specified repository.

By default only open pull requests are returned. This can be controlled
using the `state` query parameter. To retrieve pull requests that are
in one of multiple states, repeat the `state` parameter for each
individual state.

This endpoint also supports filtering and sorting of the results. See
[filtering and sorting](../../../../meta/filtering) for more details.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsGet(ctx _context.Context, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsGetExecute executes the request
	 * @return PaginatedPullrequests
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest) (PaginatedPullrequests, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPost Method for RepositoriesWorkspaceRepoSlugPullrequestsPost
	 * Creates a new pull request where the destination repository is
this repository and the author is the authenticated user.

The minimum required fields to create a pull request are `title` and
`source`, specified by a branch name.

```
curl https://api.bitbucket.org/2.0/repositories/my-username/my-repository/pullrequests \
    -u my-username:my-password \
    --request POST \
    --header 'Content-Type: application/json' \
    --data '{
        "title": "My Title",
        "source": {
            "branch": {
                "name": "staging"
            }
        }
    }'
```

If the pull request's `destination` is not specified, it will default
to the `repository.mainbranch`. To open a pull request to a
different branch, say from a feature branch to a staging branch,
specify a `destination` (same format as the `source`):

```
{
    "title": "My Title",
    "source": {
        "branch": {
            "name": "my-feature-branch"
        }
    },
    "destination": {
        "branch": {
            "name": "staging"
        }
    }
}
```

Reviewers can be specified by adding an array of user objects as the
`reviewers` property.

```
{
    "title": "My Title",
    "source": {
        "branch": {
            "name": "my-feature-branch"
        }
    },
    "reviewers": [
        {
            "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
        }
    ]
}
```

Other fields:

* `description` - a string
* `close_source_branch` - boolean that specifies if the source branch should be closed upon merging
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPost(ctx _context.Context, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPostExecute executes the request
	 * @return Pullrequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest) (Pullrequest, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet
	 * Returns a paginated list of the pull request's activity log.

This handler serves both a v20 and internal endpoint. The v20 endpoint
returns reviewer comments, updates, approvals and request changes. The internal
endpoint includes those plus tasks and attachments.

Comments created on a file or a line of code have an inline property.

Comment example:
```
{
    "pagelen": 20,
    "values": [
        {
            "comment": {
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088"
                    }
                },
                "deleted": false,
                "pullrequest": {
                    "type": "pullrequest",
                    "id": 5695,
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                        },
                        "html": {
                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                        }
                    },
                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
                },
                "content": {
                    "raw": "inline with to a dn from lines",
                    "markup": "markdown",
                    "html": "<p>inline with to a dn from lines</p>",
                    "type": "rendered"
                },
                "created_on": "2019-09-27T00:33:46.039178+00:00",
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "created_on": "2019-09-27T00:33:46.039178+00:00",
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "updated_on": "2019-09-27T00:33:46.055384+00:00",
                "inline": {
                    "context_lines": "",
                    "to": null,
                    "path": "",
                    "outdated": false,
                    "from": 211
                },
                "type": "pullrequest_comment",
                "id": 118571088
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```

Updates include a state property of OPEN, MERGED, or DECLINED.

Update example:
```
{
    "pagelen": 20,
    "values": [
        {
            "update": {
                "description": "",
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it",
                "destination": {
                    "commit": {
                        "type": "commit",
                        "hash": "6a2c16e4a152",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152"
                            }
                        }
                    },
                    "branch": {
                        "name": "master"
                    },
                    "repository": {
                        "name": "Atlaskit-MK-2",
                        "type": "repository",
                        "full_name": "atlassian/atlaskit-mk-2",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
                            },
                            "avatar": {
                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
                            }
                        },
                        "uuid": "{}"
                    }
                },
                "reason": "",
                "source": {
                    "commit": {
                        "type": "commit",
                        "hash": "728c8bad1813",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813"
                            }
                        }
                    },
                    "branch": {
                        "name": "username/NONE-add-onClick-prop-for-accessibility"
                    },
                    "repository": {
                        "name": "Atlaskit-MK-2",
                        "type": "repository",
                        "full_name": "atlassian/atlaskit-mk-2",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
                            },
                            "avatar": {
                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
                            }
                        },
                        "uuid": "{}"
                    }
                },
                "state": "OPEN",
                "author": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "date": "2019-05-10T06:48:25.305565+00:00"
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```

Approval example:
```
{
    "pagelen": 20,
    "values": [
        {
            "approval": {
                "date": "2019-09-27T00:37:19.849534+00:00",
                "pullrequest": {
                    "type": "pullrequest",
                    "id": 5695,
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                        },
                        "html": {
                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                        }
                    },
                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
                },
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                }
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetExecute executes the request
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest) (*_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete
	 * Redact the authenticated user's approval of the specified pull
request.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteExecute executes the request
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest) (*_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost
	 * Approve the specified pull request as the authenticated user.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostExecute executes the request
	 * @return Participant
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest) (Participant, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete
	 * Deletes a specific pull request comment.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param commentId The id of the comment.
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(ctx _context.Context, commentId int32, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteExecute executes the request
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest) (*_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet
	 * Returns a specific pull request comment.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param commentId The id of the comment.
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(ctx _context.Context, commentId int32, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetExecute executes the request
	 * @return PullrequestComment
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest) (PullrequestComment, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut
	 * Updates a specific pull request comment.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param commentId The id of the comment.
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(ctx _context.Context, commentId int32, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutExecute executes the request
	 * @return PullrequestComment
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest) (PullrequestComment, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet
	 * Returns a paginated list of the pull request's comments.

This includes both global, inline comments and replies.

The default sorting is oldest to newest and can be overridden with
the `sort` query parameter.

This endpoint also supports filtering and sorting of the results. See
[filtering and sorting](../../../../../../meta/filtering) for more
details.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetExecute executes the request
	 * @return PaginatedPullrequestComments
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest) (PaginatedPullrequestComments, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost
	 * Creates a new pull request comment.

Returns the newly created pull request comment.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostExecute executes the request
	 * @return PullrequestComment
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest) (PullrequestComment, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet
	 * Returns a paginated list of the pull request's commits.

These are the commits that are being merged into the destination
branch when the pull requests gets accepted.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetExecute executes the request
	 * @return ModelError
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest) (ModelError, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost
	 * Declines the pull request.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostExecute executes the request
	 * @return Pullrequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest) (Pullrequest, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet
	 * Redirects to the [repository diff](../../diff/%7Bspec%7D)
with the revspec that corresponds to the pull request.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetExecute executes the request
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest) (*_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet
	 * Redirects to the [repository diffstat](../../diffstat/%7Bspec%7D)
with the revspec that corresponds to the pull request.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetExecute executes the request
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest) (*_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet
	 * Returns the specified pull request.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetExecute executes the request
	 * @return Pullrequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest) (Pullrequest, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost
	 * Merges the pull request.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostExecute executes the request
	 * @return Pullrequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest) (Pullrequest, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet
	 * When merging a pull request takes too long, the client receives a
task ID along with a 202 status code. The task ID can be used in a call
to this endpoint to check the status of a merge task.

```
curl -X GET https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>
```

If the merge task is not yet finished, a PENDING status will be returned.

```
HTTP/2 200
{
    "task_status": "PENDING",
    "links": {
        "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>"
        }
    }
}
```

If the merge was successful, a SUCCESS status will be returned.

```
HTTP/2 200
{
    "task_status": "SUCCESS",
    "links": {
        "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>"
        }
    },
    "merge_result": <the merged pull request object>
}
```

If the merge task failed, an error will be returned.

```
{
    "type": "error",
    "error": {
        "message": "<error message>"
    }
}
```
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param taskId ID of the merge task
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet(ctx _context.Context, pullRequestId int32, repoSlug string, taskId string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetExecute executes the request
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest) (*_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet
	 * Redirects to the [repository patch](../../patch/%7Bspec%7D)
with the revspec that corresponds to pull request.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetExecute executes the request
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest) (*_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut
	 * Mutates the specified pull request.

This can be used to change the pull request's branches or description.

Only open pull requests can be mutated.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutExecute executes the request
	 * @return Pullrequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest) (Pullrequest, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteExecute executes the request
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest) (*_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostExecute executes the request
	 * @return Participant
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest) (Participant, *_nethttp.Response, error)

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet
	 * Returns all statuses (e.g. build results) for the given pull
request.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param pullRequestId The id of the pull request.
	 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
	 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
	 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest

	/*
	 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetExecute executes the request
	 * @return PaginatedCommitstatuses
	 */
	RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest) (PaginatedCommitstatuses, *_nethttp.Response, error)
}

// PullrequestsApiService PullrequestsApi service
type PullrequestsApiService service

type PullrequestsApiApiGetPullrequestsForCommitRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	workspace string
	repoSlug string
	commit string
	page *int32
	pagelen *int32
}

func (r PullrequestsApiApiGetPullrequestsForCommitRequest) Page(page int32) PullrequestsApiApiGetPullrequestsForCommitRequest {
	r.page = &page
	return r
}
func (r PullrequestsApiApiGetPullrequestsForCommitRequest) Pagelen(pagelen int32) PullrequestsApiApiGetPullrequestsForCommitRequest {
	r.pagelen = &pagelen
	return r
}

func (r PullrequestsApiApiGetPullrequestsForCommitRequest) Execute() (PaginatedPullrequests, *_nethttp.Response, error) {
	return r.ApiService.GetPullrequestsForCommitExecute(r)
}

/*
 * GetPullrequestsForCommit Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when 'Go to pull request' is clicked from the web interface for a commit's details.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces
 * @param repoSlug The repository; either the UUID in curly braces, or the slug
 * @param commit The SHA1 of the commit
 * @return PullrequestsApiApiGetPullrequestsForCommitRequest
 */
func (a *PullrequestsApiService) GetPullrequestsForCommit(ctx _context.Context, workspace string, repoSlug string, commit string) PullrequestsApiApiGetPullrequestsForCommitRequest {
	return PullrequestsApiApiGetPullrequestsForCommitRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		commit: commit,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPullrequests
 */
func (a *PullrequestsApiService) GetPullrequestsForCommitExecute(r PullrequestsApiApiGetPullrequestsForCommitRequest) (PaginatedPullrequests, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPullrequests
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.GetPullrequestsForCommit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/commit/{commit}/pullrequests"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commit"+"}", _neturl.PathEscape(parameterToString(r.commit, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pagelen != nil {
		localVarQueryParams.Add("pagelen", parameterToString(*r.pagelen, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiPullrequestsSelectedUserGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	selectedUser string
	state *string
}

func (r PullrequestsApiApiPullrequestsSelectedUserGetRequest) State(state string) PullrequestsApiApiPullrequestsSelectedUserGetRequest {
	r.state = &state
	return r
}

func (r PullrequestsApiApiPullrequestsSelectedUserGetRequest) Execute() (PaginatedPullrequests, *_nethttp.Response, error) {
	return r.ApiService.PullrequestsSelectedUserGetExecute(r)
}

/*
 * PullrequestsSelectedUserGet Method for PullrequestsSelectedUserGet
 * Returns all pull requests authored by the specified user.

By default only open pull requests are returned. This can be controlled
using the `state` query parameter. To retrieve pull requests that are
in one of multiple states, repeat the `state` parameter for each
individual state.

This endpoint also supports filtering and sorting of the results. See
[filtering and sorting](../../../../meta/filtering) for more details.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param selectedUser This can either be the username of the pull request author, the author's UUID surrounded by curly-braces, for example: `{account UUID}`, or the author's Atlassian ID. 
 * @return PullrequestsApiApiPullrequestsSelectedUserGetRequest
 */
func (a *PullrequestsApiService) PullrequestsSelectedUserGet(ctx _context.Context, selectedUser string) PullrequestsApiApiPullrequestsSelectedUserGetRequest {
	return PullrequestsApiApiPullrequestsSelectedUserGetRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPullrequests
 */
func (a *PullrequestsApiService) PullrequestsSelectedUserGetExecute(r PullrequestsApiApiPullrequestsSelectedUserGetRequest) (PaginatedPullrequests, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPullrequests
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.PullrequestsSelectedUserGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pullrequests/{selected_user}"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", _neturl.PathEscape(parameterToString(r.selectedUser, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugDefaultReviewersGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugDefaultReviewersGet Method for RepositoriesWorkspaceRepoSlugDefaultReviewersGet
 * Returns the repository's default reviewers.

These are the users that are automatically added as reviewers on every
new pull request that is created.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugDefaultReviewersGet(ctx _context.Context, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugDefaultReviewersGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugDefaultReviewersGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/default-reviewers"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	repoSlug string
	targetUsername string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest) Execute() (ModelError, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete Method for RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete
 * Removes a default reviewer from the repository.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(ctx _context.Context, repoSlug string, targetUsername string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		targetUsername: targetUsername,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return ModelError
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDeleteRequest) (ModelError, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModelError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target_username"+"}", _neturl.PathEscape(parameterToString(r.targetUsername, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	repoSlug string
	targetUsername string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest) Execute() (ModelError, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet Method for RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet
 * Returns the specified reviewer.

This can be used to test whether a user is among the repository's
default reviewers list. A 404 indicates that that specified user is not
a default reviewer.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(ctx _context.Context, repoSlug string, targetUsername string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		targetUsername: targetUsername,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return ModelError
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGetRequest) (ModelError, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModelError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target_username"+"}", _neturl.PathEscape(parameterToString(r.targetUsername, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	repoSlug string
	targetUsername string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest) Execute() (ModelError, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut Method for RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut
 * Adds the specified user to the repository's list of default
reviewers.

This method is idempotent. Adding a user a second time has no effect.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param targetUsername This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(ctx _context.Context, repoSlug string, targetUsername string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		targetUsername: targetUsername,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return ModelError
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePutRequest) (ModelError, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModelError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target_username"+"}", _neturl.PathEscape(parameterToString(r.targetUsername, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsActivityGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsActivityGet Method for RepositoriesWorkspaceRepoSlugPullrequestsActivityGet
 * Returns a paginated list of the pull request's activity log.

This handler serves both a v20 and internal endpoint. The v20 endpoint
returns reviewer comments, updates, approvals and request changes. The internal
endpoint includes those plus tasks and attachments.

Comments created on a file or a line of code have an inline property.

Comment example:
```
{
    "pagelen": 20,
    "values": [
        {
            "comment": {
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088"
                    }
                },
                "deleted": false,
                "pullrequest": {
                    "type": "pullrequest",
                    "id": 5695,
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                        },
                        "html": {
                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                        }
                    },
                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
                },
                "content": {
                    "raw": "inline with to a dn from lines",
                    "markup": "markdown",
                    "html": "<p>inline with to a dn from lines</p>",
                    "type": "rendered"
                },
                "created_on": "2019-09-27T00:33:46.039178+00:00",
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "created_on": "2019-09-27T00:33:46.039178+00:00",
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "updated_on": "2019-09-27T00:33:46.055384+00:00",
                "inline": {
                    "context_lines": "",
                    "to": null,
                    "path": "",
                    "outdated": false,
                    "from": 211
                },
                "type": "pullrequest_comment",
                "id": 118571088
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```

Updates include a state property of OPEN, MERGED, or DECLINED.

Update example:
```
{
    "pagelen": 20,
    "values": [
        {
            "update": {
                "description": "",
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it",
                "destination": {
                    "commit": {
                        "type": "commit",
                        "hash": "6a2c16e4a152",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152"
                            }
                        }
                    },
                    "branch": {
                        "name": "master"
                    },
                    "repository": {
                        "name": "Atlaskit-MK-2",
                        "type": "repository",
                        "full_name": "atlassian/atlaskit-mk-2",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
                            },
                            "avatar": {
                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
                            }
                        },
                        "uuid": "{}"
                    }
                },
                "reason": "",
                "source": {
                    "commit": {
                        "type": "commit",
                        "hash": "728c8bad1813",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813"
                            }
                        }
                    },
                    "branch": {
                        "name": "username/NONE-add-onClick-prop-for-accessibility"
                    },
                    "repository": {
                        "name": "Atlaskit-MK-2",
                        "type": "repository",
                        "full_name": "atlassian/atlaskit-mk-2",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
                            },
                            "avatar": {
                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
                            }
                        },
                        "uuid": "{}"
                    }
                },
                "state": "OPEN",
                "author": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "date": "2019-05-10T06:48:25.305565+00:00"
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```

Approval example:
```
{
    "pagelen": 20,
    "values": [
        {
            "approval": {
                "date": "2019-09-27T00:37:19.849534+00:00",
                "pullrequest": {
                    "type": "pullrequest",
                    "id": 5695,
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                        },
                        "html": {
                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                        }
                    },
                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
                },
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                }
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsActivityGet(ctx _context.Context, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsActivityGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsActivityGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsActivityGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/activity"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	repoSlug string
	workspace string
	state *string
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest) State(state string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest {
	r.state = &state
	return r
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest) Execute() (PaginatedPullrequests, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsGet Method for RepositoriesWorkspaceRepoSlugPullrequestsGet
 * Returns all pull requests on the specified repository.

By default only open pull requests are returned. This can be controlled
using the `state` query parameter. To retrieve pull requests that are
in one of multiple states, repeat the `state` parameter for each
individual state.

This endpoint also supports filtering and sorting of the results. See
[filtering and sorting](../../../../meta/filtering) for more details.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsGet(ctx _context.Context, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPullrequests
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsGetRequest) (PaginatedPullrequests, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPullrequests
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	repoSlug string
	workspace string
	body *Pullrequest
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest) Body(body Pullrequest) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest {
	r.body = &body
	return r
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest) Execute() (Pullrequest, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPost Method for RepositoriesWorkspaceRepoSlugPullrequestsPost
 * Creates a new pull request where the destination repository is
this repository and the author is the authenticated user.

The minimum required fields to create a pull request are `title` and
`source`, specified by a branch name.

```
curl https://api.bitbucket.org/2.0/repositories/my-username/my-repository/pullrequests \
    -u my-username:my-password \
    --request POST \
    --header 'Content-Type: application/json' \
    --data '{
        "title": "My Title",
        "source": {
            "branch": {
                "name": "staging"
            }
        }
    }'
```

If the pull request's `destination` is not specified, it will default
to the `repository.mainbranch`. To open a pull request to a
different branch, say from a feature branch to a staging branch,
specify a `destination` (same format as the `source`):

```
{
    "title": "My Title",
    "source": {
        "branch": {
            "name": "my-feature-branch"
        }
    },
    "destination": {
        "branch": {
            "name": "staging"
        }
    }
}
```

Reviewers can be specified by adding an array of user objects as the
`reviewers` property.

```
{
    "title": "My Title",
    "source": {
        "branch": {
            "name": "my-feature-branch"
        }
    },
    "reviewers": [
        {
            "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
        }
    ]
}
```

Other fields:

* `description` - a string
* `close_source_branch` - boolean that specifies if the source branch should be closed upon merging
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPost(ctx _context.Context, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Pullrequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPostRequest) (Pullrequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Pullrequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet
 * Returns a paginated list of the pull request's activity log.

This handler serves both a v20 and internal endpoint. The v20 endpoint
returns reviewer comments, updates, approvals and request changes. The internal
endpoint includes those plus tasks and attachments.

Comments created on a file or a line of code have an inline property.

Comment example:
```
{
    "pagelen": 20,
    "values": [
        {
            "comment": {
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088"
                    }
                },
                "deleted": false,
                "pullrequest": {
                    "type": "pullrequest",
                    "id": 5695,
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                        },
                        "html": {
                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                        }
                    },
                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
                },
                "content": {
                    "raw": "inline with to a dn from lines",
                    "markup": "markdown",
                    "html": "<p>inline with to a dn from lines</p>",
                    "type": "rendered"
                },
                "created_on": "2019-09-27T00:33:46.039178+00:00",
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "created_on": "2019-09-27T00:33:46.039178+00:00",
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "updated_on": "2019-09-27T00:33:46.055384+00:00",
                "inline": {
                    "context_lines": "",
                    "to": null,
                    "path": "",
                    "outdated": false,
                    "from": 211
                },
                "type": "pullrequest_comment",
                "id": 118571088
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```

Updates include a state property of OPEN, MERGED, or DECLINED.

Update example:
```
{
    "pagelen": 20,
    "values": [
        {
            "update": {
                "description": "",
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it",
                "destination": {
                    "commit": {
                        "type": "commit",
                        "hash": "6a2c16e4a152",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152"
                            }
                        }
                    },
                    "branch": {
                        "name": "master"
                    },
                    "repository": {
                        "name": "Atlaskit-MK-2",
                        "type": "repository",
                        "full_name": "atlassian/atlaskit-mk-2",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
                            },
                            "avatar": {
                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
                            }
                        },
                        "uuid": "{}"
                    }
                },
                "reason": "",
                "source": {
                    "commit": {
                        "type": "commit",
                        "hash": "728c8bad1813",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813"
                            }
                        }
                    },
                    "branch": {
                        "name": "username/NONE-add-onClick-prop-for-accessibility"
                    },
                    "repository": {
                        "name": "Atlaskit-MK-2",
                        "type": "repository",
                        "full_name": "atlassian/atlaskit-mk-2",
                        "links": {
                            "self": {
                                "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2"
                            },
                            "html": {
                                "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
                            },
                            "avatar": {
                                "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
                            }
                        },
                        "uuid": "{}"
                    }
                },
                "state": "OPEN",
                "author": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                },
                "date": "2019-05-10T06:48:25.305565+00:00"
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```

Approval example:
```
{
    "pagelen": 20,
    "values": [
        {
            "approval": {
                "date": "2019-09-27T00:37:19.849534+00:00",
                "pullrequest": {
                    "type": "pullrequest",
                    "id": 5695,
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                        },
                        "html": {
                            "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                        }
                    },
                    "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
                },
                "user": {
                    "display_name": "Name Lastname",
                    "uuid": "{}",
                    "links": {
                        "self": {
                            "href": "https://bitbucket.org/!api/2.0/users/%7B%7D"
                        },
                        "html": {
                            "href": "https://bitbucket.org/%7B%7D/"
                        },
                        "avatar": {
                            "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
                        }
                    },
                    "type": "user",
                    "nickname": "Name",
                    "account_id": ""
                }
            },
            "pull_request": {
                "type": "pullrequest",
                "id": 5695,
                "links": {
                    "self": {
                        "href": "https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
                    },
                    "html": {
                        "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
                    }
                },
                "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
            }
        }
    ]
}
```
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/activity"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete
 * Redact the authenticated user's approval of the specified pull
request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/approve"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest) Execute() (Participant, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost
 * Approve the specified pull request as the authenticated user.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Participant
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePostRequest) (Participant, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Participant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/approve"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	commentId int32
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete
 * Deletes a specific pull request comment.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param commentId The id of the comment.
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(ctx _context.Context, commentId int32, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", _neturl.PathEscape(parameterToString(r.commentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	commentId int32
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest) Execute() (PullrequestComment, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet
 * Returns a specific pull request comment.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param commentId The id of the comment.
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(ctx _context.Context, commentId int32, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PullrequestComment
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGetRequest) (PullrequestComment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PullrequestComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", _neturl.PathEscape(parameterToString(r.commentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	commentId int32
	pullRequestId int32
	repoSlug string
	workspace string
	body *PullrequestComment
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest) Body(body PullrequestComment) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest {
	r.body = &body
	return r
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest) Execute() (PullrequestComment, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut
 * Updates a specific pull request comment.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param commentId The id of the comment.
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(ctx _context.Context, commentId int32, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PullrequestComment
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPutRequest) (PullrequestComment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PullrequestComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", _neturl.PathEscape(parameterToString(r.commentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest) Execute() (PaginatedPullrequestComments, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet
 * Returns a paginated list of the pull request's comments.

This includes both global, inline comments and replies.

The default sorting is oldest to newest and can be overridden with
the `sort` query parameter.

This endpoint also supports filtering and sorting of the results. See
[filtering and sorting](../../../../../../meta/filtering) for more
details.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedPullrequestComments
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGetRequest) (PaginatedPullrequestComments, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPullrequestComments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
	body *PullrequestComment
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest) Body(body PullrequestComment) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest {
	r.body = &body
	return r
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest) Execute() (PullrequestComment, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost
 * Creates a new pull request comment.

Returns the newly created pull request comment.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PullrequestComment
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPostRequest) (PullrequestComment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PullrequestComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest) Execute() (ModelError, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet
 * Returns a paginated list of the pull request's commits.

These are the commits that are being merged into the destination
branch when the pull requests gets accepted.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return ModelError
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGetRequest) (ModelError, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModelError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/commits"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest) Execute() (Pullrequest, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost
 * Declines the pull request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Pullrequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePostRequest) (Pullrequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Pullrequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/decline"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 555 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet
 * Redirects to the [repository diff](../../diff/%7Bspec%7D)
with the revspec that corresponds to the pull request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/diff"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet
 * Redirects to the [repository diffstat](../../diffstat/%7Bspec%7D)
with the revspec that corresponds to the pull request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/diffstat"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest) Execute() (Pullrequest, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet
 * Returns the specified pull request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Pullrequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGetRequest) (Pullrequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Pullrequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
	async *bool
	body *PullrequestMergeParameters
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest) Async(async bool) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest {
	r.async = &async
	return r
}
func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest) Body(body PullrequestMergeParameters) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest {
	r.body = &body
	return r
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest) Execute() (Pullrequest, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost
 * Merges the pull request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Pullrequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePostRequest) (Pullrequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Pullrequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/merge"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.async != nil {
		localVarQueryParams.Add("async", parameterToString(*r.async, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 555 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	taskId string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet
 * When merging a pull request takes too long, the client receives a
task ID along with a 202 status code. The task ID can be used in a call
to this endpoint to check the status of a merge task.

```
curl -X GET https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>
```

If the merge task is not yet finished, a PENDING status will be returned.

```
HTTP/2 200
{
    "task_status": "PENDING",
    "links": {
        "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>"
        }
    }
}
```

If the merge was successful, a SUCCESS status will be returned.

```
HTTP/2 200
{
    "task_status": "SUCCESS",
    "links": {
        "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>"
        }
    },
    "merge_result": <the merged pull request object>
}
```

If the merge task failed, an error will be returned.

```
{
    "type": "error",
    "error": {
        "message": "<error message>"
    }
}
```
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param taskId ID of the merge task
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet(ctx _context.Context, pullRequestId int32, repoSlug string, taskId string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		taskId: taskId,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/merge/task-status/{task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", _neturl.PathEscape(parameterToString(r.taskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet
 * Redirects to the [repository patch](../../patch/%7Bspec%7D)
with the revspec that corresponds to pull request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/patch"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
	body *Pullrequest
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest) Body(body Pullrequest) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest {
	r.body = &body
	return r
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest) Execute() (Pullrequest, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut
 * Mutates the specified pull request.

This can be used to change the pull request's branches or description.

Only open pull requests can be mutated.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Pullrequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPutRequest) (Pullrequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Pullrequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/request-changes"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
}


func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest) Execute() (Participant, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Participant
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPostRequest) (Participant, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Participant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/request-changes"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest struct {
	ctx _context.Context
	ApiService PullrequestsApi
	pullRequestId int32
	repoSlug string
	workspace string
	q *string
	sort *string
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest) Q(q string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest {
	r.q = &q
	return r
}
func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest) Sort(sort string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest {
	r.sort = &sort
	return r
}

func (r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest) Execute() (PaginatedCommitstatuses, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet Method for RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet
 * Returns all statuses (e.g. build results) for the given pull
request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pullRequestId The id of the pull request.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(ctx _context.Context, pullRequestId int32, repoSlug string, workspace string) PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest {
	return PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest{
		ApiService: a,
		ctx: ctx,
		pullRequestId: pullRequestId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedCommitstatuses
 */
func (a *PullrequestsApiService) RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetExecute(r PullrequestsApiApiRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGetRequest) (PaginatedCommitstatuses, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedCommitstatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PullrequestsApiService.RepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/statuses"
	localVarPath = strings.Replace(localVarPath, "{"+"pull_request_id"+"}", _neturl.PathEscape(parameterToString(r.pullRequestId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
